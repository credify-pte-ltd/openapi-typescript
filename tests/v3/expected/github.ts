/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface components {
  /** Simple User */
  simpleUser: {
    login: string;
    id: number;
    nodeId: string;
    avatarUrl: string;
    gravatarId: string | null;
    url: string;
    htmlUrl: string;
    followersUrl: string;
    followingUrl: string;
    gistsUrl: string;
    starredUrl: string;
    subscriptionsUrl: string;
    organizationsUrl: string;
    reposUrl: string;
    eventsUrl: string;
    receivedEventsUrl: string;
    type: string;
    siteAdmin: boolean;
    starredAt?: string;
  } | null;
  /** GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub. */
  integration: {
    /** Unique identifier of the GitHub app */
    id: number;
    /** The slug name of the GitHub app */
    slug?: string;
    nodeId: string;
    owner: components["simple-user"] | null;
    /** The name of the GitHub app */
    name: string;
    description: string | null;
    externalUrl: string;
    htmlUrl: string;
    createdAt: string;
    updatedAt: string;
    /** The set of permissions for the GitHub app */
    permissions: {
      issues?: string;
      checks?: string;
      metadata?: string;
      contents?: string;
      deployments?: string;
    } & { [key: string]: string };
    /** The list of events for the GitHub app */
    events: string[];
    /** The number of installations associated with the GitHub app */
    installationsCount?: number;
    clientId?: string;
    clientSecret?: string;
    webhookSecret?: string;
    pem?: string;
  } & { [key: string]: any };
  /** Basic Error */
  basicError: {
    message?: string;
    documentationUrl?: string;
  };
  /** Validation Error Simple */
  validationErrorSimple: {
    message: string;
    documentationUrl: string;
    errors?: string[];
  };
  /** The URL to which the payloads will be delivered. */
  webhookConfigUrl: string;
  /** The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`. */
  webhookConfigContentType: string;
  /** If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers). */
  webhookConfigSecret: string;
  /** Determines whether the SSL certificate of the host for `url` will be verified when delivering payloads. Supported values include `0` (verification is performed) and `1` (verification is not performed). The default is `0`. **We strongly recommend not setting this to `1` as you are subject to man-in-the-middle and other attacks.** */
  webhookConfigInsecureSsl: string;
  /** Configuration object of the webhook */
  webhookConfig: {
    url?: components["webhook-config-url"];
    contentType?: components["webhook-config-content-type"];
    secret?: components["webhook-config-secret"];
    insecureSsl?: components["webhook-config-insecure-ssl"];
  };
  /** An enterprise account */
  enterprise: {
    /** A short description of the enterprise. */
    description?: string | null;
    htmlUrl: string;
    /** The enterprise's website URL. */
    websiteUrl?: string | null;
    /** Unique identifier of the enterprise */
    id: number;
    nodeId: string;
    /** The name of the enterprise. */
    name: string;
    /** The slug url identifier for the enterprise. */
    slug: string;
    createdAt: string | null;
    updatedAt: string | null;
    avatarUrl: string;
  };
  /** Installation */
  installation: {
    /** The ID of the installation. */
    id: number;
    account:
      | (Partial<components["simple-user"]> & Partial<components["enterprise"]>)
      | null;
    /** Describe whether all repositories have been selected or there's a selection involved */
    repositorySelection: "all" | "selected";
    accessTokensUrl: string;
    repositoriesUrl: string;
    htmlUrl: string;
    appId: number;
    /** The ID of the user or organization this token is being scoped to. */
    targetId: number;
    targetType: string;
    permissions: {
      deployments?: string;
      checks?: string;
      metadata?: string;
      contents?: string;
      pullRequests?: string;
      statuses?: string;
      issues?: string;
      organizationAdministration?: string;
    };
    events: string[];
    createdAt: string;
    updatedAt: string;
    singleFileName: string | null;
    hasMultipleSingleFiles?: boolean;
    singleFilePaths?: string[];
    appSlug: string;
    suspendedBy?: components["simple-user"] | null;
    suspendedAt?: string | null;
    contactEmail?: string | null;
  };
  /** License Simple */
  licenseSimple: {
    key: string;
    name: string;
    url: string | null;
    spdxId: string | null;
    nodeId: string;
    htmlUrl?: string;
  };
  /** A git repository */
  repository: {
    /** Unique identifier of the repository */
    id: number;
    nodeId: string;
    /** The name of the repository. */
    name: string;
    fullName: string;
    license: components["license-simple"] | null;
    forks: number;
    permissions?: {
      admin: boolean;
      pull: boolean;
      triage?: boolean;
      push: boolean;
      maintain?: boolean;
    };
    owner: components["simple-user"] | null;
    /** Whether the repository is private or public. */
    private: boolean;
    htmlUrl: string;
    description: string | null;
    fork: boolean;
    url: string;
    archiveUrl: string;
    assigneesUrl: string;
    blobsUrl: string;
    branchesUrl: string;
    collaboratorsUrl: string;
    commentsUrl: string;
    commitsUrl: string;
    compareUrl: string;
    contentsUrl: string;
    contributorsUrl: string;
    deploymentsUrl: string;
    downloadsUrl: string;
    eventsUrl: string;
    forksUrl: string;
    gitCommitsUrl: string;
    gitRefsUrl: string;
    gitTagsUrl: string;
    gitUrl: string;
    issueCommentUrl: string;
    issueEventsUrl: string;
    issuesUrl: string;
    keysUrl: string;
    labelsUrl: string;
    languagesUrl: string;
    mergesUrl: string;
    milestonesUrl: string;
    notificationsUrl: string;
    pullsUrl: string;
    releasesUrl: string;
    sshUrl: string;
    stargazersUrl: string;
    statusesUrl: string;
    subscribersUrl: string;
    subscriptionUrl: string;
    tagsUrl: string;
    teamsUrl: string;
    treesUrl: string;
    cloneUrl: string;
    mirrorUrl: string | null;
    hooksUrl: string;
    svnUrl: string;
    homepage: string | null;
    language: string | null;
    forksCount: number;
    stargazersCount: number;
    watchersCount: number;
    size: number;
    /** The default branch of the repository. */
    defaultBranch: string;
    openIssuesCount: number;
    /** Whether this repository acts as a template that can be used to generate new repositories. */
    isTemplate?: boolean;
    topics?: string[];
    /** Whether issues are enabled. */
    hasIssues: boolean;
    /** Whether projects are enabled. */
    hasProjects: boolean;
    /** Whether the wiki is enabled. */
    hasWiki: boolean;
    hasPages: boolean;
    /** Whether downloads are enabled. */
    hasDownloads: boolean;
    /** Whether the repository is archived. */
    archived: boolean;
    /** Returns whether or not this repository disabled. */
    disabled: boolean;
    /** The repository visibility: public, private, or internal. */
    visibility?: string;
    pushedAt: string | null;
    createdAt: string | null;
    updatedAt: string | null;
    /** Whether to allow rebase merges for pull requests. */
    allowRebaseMerge?: boolean;
    templateRepository?: {
      id?: number;
      nodeId?: string;
      name?: string;
      fullName?: string;
      owner?: {
        login?: string;
        id?: number;
        nodeId?: string;
        avatarUrl?: string;
        gravatarId?: string;
        url?: string;
        htmlUrl?: string;
        followersUrl?: string;
        followingUrl?: string;
        gistsUrl?: string;
        starredUrl?: string;
        subscriptionsUrl?: string;
        organizationsUrl?: string;
        reposUrl?: string;
        eventsUrl?: string;
        receivedEventsUrl?: string;
        type?: string;
        siteAdmin?: boolean;
      };
      private?: boolean;
      htmlUrl?: string;
      description?: string;
      fork?: boolean;
      url?: string;
      archiveUrl?: string;
      assigneesUrl?: string;
      blobsUrl?: string;
      branchesUrl?: string;
      collaboratorsUrl?: string;
      commentsUrl?: string;
      commitsUrl?: string;
      compareUrl?: string;
      contentsUrl?: string;
      contributorsUrl?: string;
      deploymentsUrl?: string;
      downloadsUrl?: string;
      eventsUrl?: string;
      forksUrl?: string;
      gitCommitsUrl?: string;
      gitRefsUrl?: string;
      gitTagsUrl?: string;
      gitUrl?: string;
      issueCommentUrl?: string;
      issueEventsUrl?: string;
      issuesUrl?: string;
      keysUrl?: string;
      labelsUrl?: string;
      languagesUrl?: string;
      mergesUrl?: string;
      milestonesUrl?: string;
      notificationsUrl?: string;
      pullsUrl?: string;
      releasesUrl?: string;
      sshUrl?: string;
      stargazersUrl?: string;
      statusesUrl?: string;
      subscribersUrl?: string;
      subscriptionUrl?: string;
      tagsUrl?: string;
      teamsUrl?: string;
      treesUrl?: string;
      cloneUrl?: string;
      mirrorUrl?: string;
      hooksUrl?: string;
      svnUrl?: string;
      homepage?: string;
      language?: string;
      forksCount?: number;
      stargazersCount?: number;
      watchersCount?: number;
      size?: number;
      defaultBranch?: string;
      openIssuesCount?: number;
      isTemplate?: boolean;
      topics?: string[];
      hasIssues?: boolean;
      hasProjects?: boolean;
      hasWiki?: boolean;
      hasPages?: boolean;
      hasDownloads?: boolean;
      archived?: boolean;
      disabled?: boolean;
      visibility?: string;
      pushedAt?: string;
      createdAt?: string;
      updatedAt?: string;
      permissions?: {
        admin?: boolean;
        push?: boolean;
        pull?: boolean;
      };
      allowRebaseMerge?: boolean;
      templateRepository?: string;
      tempCloneToken?: string;
      allowSquashMerge?: boolean;
      deleteBranchOnMerge?: boolean;
      allowMergeCommit?: boolean;
      subscribersCount?: number;
      networkCount?: number;
    } | null;
    tempCloneToken?: string;
    /** Whether to allow squash merges for pull requests. */
    allowSquashMerge?: boolean;
    /** Whether to delete head branches when pull requests are merged */
    deleteBranchOnMerge?: boolean;
    /** Whether to allow merge commits for pull requests. */
    allowMergeCommit?: boolean;
    subscribersCount?: number;
    networkCount?: number;
    openIssues: number;
    watchers: number;
    masterBranch?: string;
    starredAt?: string;
  };
  /** Authentication token for a GitHub App installed on a user or org. */
  installationToken: {
    token?: string;
    expiresAt?: string;
    permissions?: {
      issues?: string;
      contents?: string;
      metadata?: string;
      singleFile?: string;
    };
    repositorySelection?: "all" | "selected";
    repositories?: components["repository"][];
    singleFile?: string;
    hasMultipleSingleFiles?: boolean;
    singleFilePaths?: string[];
  };
  /** Validation Error */
  validationError: {
    message: string;
    documentationUrl: string;
    errors?: {
      resource?: string;
      field?: string;
      message?: string;
      code: string;
      index?: number;
      value?: (string | null) | (number | null) | (string[] | null);
    }[];
  };
  /** The authorization associated with an OAuth Access. */
  applicationGrant: {
    id: number;
    url: string;
    app: {
      clientId: string;
      name: string;
      url: string;
    };
    createdAt: string;
    updatedAt: string;
    scopes: string[];
    user?: components["simple-user"] | null;
  };
  scopedInstallation: {
    permissions: { [key: string]: any };
    /** Describe whether all repositories have been selected or there's a selection involved */
    repositorySelection: "all" | "selected";
    singleFileName: string | null;
    hasMultipleSingleFiles?: boolean;
    singleFilePaths?: string[];
    repositoriesUrl: string;
    account: components["simple-user"];
  };
  /** The authorization for an OAuth app, GitHub App, or a Personal Access Token. */
  authorization: {
    id: number;
    url: string;
    /** A list of scopes that this authorization is in. */
    scopes: string[] | null;
    token: string;
    tokenLastEight: string | null;
    hashedToken: string | null;
    app: {
      clientId: string;
      name: string;
      url: string;
    };
    note: string | null;
    noteUrl: string | null;
    updatedAt: string;
    createdAt: string;
    fingerprint: string | null;
    user?: components["simple-user"] | null;
    installation?: components["scoped-installation"] | null;
  };
  /** Code Of Conduct */
  codeOfConduct: {
    key: string;
    name: string;
    url: string;
    body?: string;
    htmlUrl: string | null;
  };
  /** Content Reference attachments allow you to provide context around URLs posted in comments */
  contentReferenceAttachment: {
    /** The ID of the attachment */
    id: number;
    /** The title of the attachment */
    title: string;
    /** The body of the attachment */
    body: string;
    /** The node_id of the content attachment */
    nodeId?: string;
  };
  /** The policy that controls the organizations in the enterprise that are allowed to run GitHub Actions. Can be one of: `all`, `none`, or `selected`. */
  enabledOrganizations: "all" | "none" | "selected";
  /** The permissions policy that controls the actions that are allowed to run. Can be one of: `all`, `local_only`, or `selected`. */
  allowedActions: "all" | "local_only" | "selected";
  /** The API URL to use to get or set the actions that are allowed to run, when `allowed_actions` is set to `selected`. */
  selectedActionsUrl: string;
  actionsEnterprisePermissions: {
    enabledOrganizations?: components["enabled-organizations"];
    /** The API URL to use to get or set the selected organizations that are allowed to run GitHub Actions, when `enabled_organizations` is set to `selected`. */
    selectedOrganizationsUrl?: string;
    allowedActions?: components["allowed-actions"];
    selectedActionsUrl?: components["selected-actions-url"];
  };
  /** Organization Simple */
  organizationSimple: {
    login: string;
    id: number;
    nodeId: string;
    url: string;
    reposUrl: string;
    eventsUrl: string;
    hooksUrl: string;
    issuesUrl: string;
    membersUrl: string;
    publicMembersUrl: string;
    avatarUrl: string;
    description: string | null;
  };
  selectedActions: {
    /** Whether GitHub-owned actions are allowed. For example, this includes the actions in the `actions` organization. */
    githubOwnedAllowed?: boolean;
    /** Whether actions in GitHub Marketplace from verified creators are allowed. Set to `true` to allow all GitHub Marketplace actions by verified creators. */
    verifiedAllowed?: boolean;
    /** Specifies a list of string-matching patterns to allow specific action(s). Wildcards, tags, and SHAs are allowed. For example, `monalisa/octocat@*`, `monalisa/octocat@v2`, `monalisa/*`." */
    patternsAllowed?: string[];
  };
  runnerGroupsEnterprise: {
    id?: number;
    name?: string;
    visibility?: string;
    default?: boolean;
    selectedOrganizationsUrl?: string;
    runnersUrl?: string;
  };
  /** A self hosted runner */
  runner: {
    /** The id of the runner. */
    id: number;
    /** The name of the runner. */
    name: string;
    /** The Operating System of the runner. */
    os: string;
    /** The status of the runner. */
    status: string;
    busy: boolean;
    labels: {
      /** Unique identifier of the label. */
      id?: number;
      /** Name of the label. */
      name?: string;
      /** The type of label. Read-only labels are applied automatically when the runner is configured. */
      type?: "read-only" | "custom";
    }[];
  };
  /** Runner Application */
  runnerApplication: {
    os?: string;
    architecture?: string;
    downloadUrl?: string;
    filename?: string;
  };
  /** Authentication Token */
  authenticationToken: {
    /** The token used for authentication */
    token: string;
    /** The time this token expires */
    expiresAt: string;
    permissions?: { [key: string]: any };
    /** The repositories this token has access to */
    repositories?: components["repository"][];
    singleFile?: string | null;
    /** Describe whether all repositories have been selected or there's a selection involved */
    repositorySelection?: "all" | "selected";
  };
  actionsBillingUsage: {
    /** The sum of the free and paid GitHub Actions minutes used. */
    totalMinutesUsed?: number;
    /** The total paid GitHub Actions minutes used. */
    totalPaidMinutesUsed?: number;
    /** The amount of free GitHub Actions minutes available. */
    includedMinutes?: number;
    minutesUsedBreakdown?: {
      /** Total minutes used on Ubuntu runner machines. */
      UBUNTU?: number;
      /** Total minutes used on macOS runner machines. */
      MACOS?: number;
      /** Total minutes used on Windows runner machines. */
      WINDOWS?: number;
    };
  };
  packagesBillingUsage: {
    /** Sum of the free and paid storage space (GB) for GitHuub Packages. */
    totalGigabytesBandwidthUsed?: number;
    /** Total paid storage space (GB) for GitHuub Packages. */
    totalPaidGigabytesBandwidthUsed?: number;
    /** Free storage space (GB) for GitHub Packages. */
    includedGigabytesBandwidth?: number;
  };
  combinedBillingUsage: {
    /** Numbers of days left in billing cycle. */
    daysLeftInBillingCycle?: number;
    /** Estimated storage space (GB) used in billing cycle. */
    estimatedPaidStorageForMonth?: number;
    /** Estimated sum of free and paid storage space (GB) used in billing cycle. */
    estimatedStorageForMonth?: number;
  };
  /** Actor */
  actor: {
    id: number;
    login: string;
    displayLogin?: string;
    gravatarId: string | null;
    url: string;
    avatarUrl: string;
  };
  /** A collection of related issues and pull requests. */
  milestone: {
    url: string;
    htmlUrl: string;
    labelsUrl: string;
    id: number;
    nodeId: string;
    /** The number of the milestone. */
    number: number;
    /** The state of the milestone. */
    state: "open" | "closed";
    /** The title of the milestone. */
    title: string;
    description: string | null;
    creator: components["simple-user"] | null;
    openIssues: number;
    closedIssues: number;
    createdAt: string;
    updatedAt: string;
    closedAt: string | null;
    dueOn: string | null;
  };
  /** Issue Simple */
  issueSimple: {
    id: number;
    nodeId: string;
    url: string;
    repositoryUrl: string;
    labelsUrl: string;
    commentsUrl: string;
    eventsUrl: string;
    htmlUrl: string;
    number: number;
    state: string;
    title: string;
    body?: string;
    user: components["simple-user"] | null;
    labels: {
      id?: number;
      nodeId?: string;
      url?: string;
      name?: string;
      description?: string | null;
      color?: string;
      default?: boolean;
    }[];
    assignee: components["simple-user"] | null;
    assignees?: components["simple-user"][] | null;
    milestone: components["milestone"] | null;
    locked: boolean;
    activeLockReason?: string | null;
    comments: number;
    pullRequest?: {
      mergedAt?: string | null;
      diffUrl: string | null;
      htmlUrl: string | null;
      patchUrl: string | null;
      url: string | null;
    };
    closedAt: string | null;
    createdAt: string;
    updatedAt: string;
    authorAssociation: string;
    bodyHtml?: string;
    bodyText?: string;
    timelineUrl?: string;
    repository?: components["repository"];
    performedViaGithubApp?: components["integration"] | null;
  };
  reactionRollup: {
    url: string;
    totalCount: number;
    "+1": number;
    "-1": number;
    laugh: number;
    confused: number;
    heart: number;
    hooray: number;
    eyes: number;
    rocket: number;
  };
  /** Comments provide a way for people to collaborate on an issue. */
  issueComment: {
    /** Unique identifier of the issue comment */
    id: number;
    nodeId: string;
    /** URL for the issue comment */
    url: string;
    /** Contents of the issue comment */
    body?: string;
    bodyText?: string;
    bodyHtml?: string;
    htmlUrl: string;
    user: components["simple-user"] | null;
    createdAt: string;
    updatedAt: string;
    issueUrl: string;
    authorAssociation:
      | "collaborator"
      | "contributor"
      | "first_timer"
      | "first_time_contributor"
      | "mannequin"
      | "member"
      | "none"
      | "owner";
    performedViaGithubApp?: components["integration"] | null;
    reactions?: components["reaction-rollup"];
  };
  /** Event */
  event: {
    id: string;
    type: string | null;
    actor: components["actor"];
    repo: {
      id: number;
      name: string;
      url: string;
    };
    org?: components["actor"];
    payload: {
      action: string;
      issue?: components["issue-simple"];
      comment?: components["issue-comment"];
      pages?: {
        pageName?: string;
        title?: string;
        summary?: string | null;
        action?: string;
        sha?: string;
        htmlUrl?: string;
      }[];
    };
    public: boolean;
    createdAt: string | null;
  };
  /** Hypermedia Link with Type */
  linkWithType: {
    href: string;
    type: string;
  };
  /** Feed */
  feed: {
    timelineUrl: string;
    userUrl: string;
    currentUserPublicUrl?: string;
    currentUserUrl?: string;
    currentUserActorUrl?: string;
    currentUserOrganizationUrl?: string;
    currentUserOrganizationUrls?: string[];
    securityAdvisoriesUrl?: string;
    Links: {
      timeline: components["link-with-type"];
      user: components["link-with-type"];
      securityAdvisories?: components["link-with-type"];
      currentUser?: components["link-with-type"];
      currentUserPublic?: components["link-with-type"];
      currentUserActor?: components["link-with-type"];
      currentUserOrganization?: components["link-with-type"];
      currentUserOrganizations?: components["link-with-type"][];
    };
  };
  /** Base Gist */
  baseGist: {
    url: string;
    forksUrl: string;
    commitsUrl: string;
    id: string;
    nodeId: string;
    gitPullUrl: string;
    gitPushUrl: string;
    htmlUrl: string;
    files: {
      [key: string]: {
        filename?: string;
        type?: string;
        language?: string;
        rawUrl?: string;
        size?: number;
      };
    };
    public: boolean;
    createdAt: string;
    updatedAt: string;
    description: string | null;
    comments: number;
    user: components["simple-user"] | null;
    commentsUrl: string;
    owner?: components["simple-user"] | null;
    truncated?: boolean;
    forks?: { [key: string]: any }[];
    history?: { [key: string]: any }[];
  };
  /** Gist Simple */
  gistSimple: {
    url?: string;
    forksUrl?: string;
    commitsUrl?: string;
    id?: string;
    nodeId?: string;
    gitPullUrl?: string;
    gitPushUrl?: string;
    htmlUrl?: string;
    files?: {
      [key: string]: {
        filename?: string;
        type?: string;
        language?: string;
        rawUrl?: string;
        size?: number;
        truncated?: boolean;
        content?: string;
      } | null;
    };
    public?: boolean;
    createdAt?: string;
    updatedAt?: string;
    description?: string | null;
    comments?: number;
    user?: string | null;
    commentsUrl?: string;
    owner?: components["simple-user"];
    truncated?: boolean;
  };
  /** Gist Full */
  gistFull: components["gist-simple"] & {
    forks?: {
      user?: {
        login?: string;
        id?: number;
        nodeId?: string;
        avatarUrl?: string;
        gravatarId?: string;
        url?: string;
        htmlUrl?: string;
        followersUrl?: string;
        followingUrl?: string;
        gistsUrl?: string;
        starredUrl?: string;
        subscriptionsUrl?: string;
        organizationsUrl?: string;
        reposUrl?: string;
        eventsUrl?: string;
        receivedEventsUrl?: string;
        type?: string;
        siteAdmin?: boolean;
      };
      url?: string;
      id?: string;
      createdAt?: string;
      updatedAt?: string;
    }[];
    history?: {
      url?: string;
      version?: string;
      user?: {
        login?: string;
        id?: number;
        nodeId?: string;
        avatarUrl?: string;
        gravatarId?: string;
        url?: string;
        htmlUrl?: string;
        followersUrl?: string;
        followingUrl?: string;
        gistsUrl?: string;
        starredUrl?: string;
        subscriptionsUrl?: string;
        organizationsUrl?: string;
        reposUrl?: string;
        eventsUrl?: string;
        receivedEventsUrl?: string;
        type?: string;
        siteAdmin?: boolean;
      } | null;
      changeStatus?: {
        deletions?: number;
        additions?: number;
        total?: number;
      };
      committedAt?: string;
    }[];
    forkOf?: components["gist-simple"] | null;
    url?: string;
    forksUrl?: string;
    commitsUrl?: string;
    id?: string;
    nodeId?: string;
    gitPullUrl?: string;
    gitPushUrl?: string;
    htmlUrl?: string;
    createdAt?: string;
    updatedAt?: string;
    description?: string | null;
    comments?: number;
    commentsUrl?: string;
  };
  /** A comment made to a gist. */
  gistComment: {
    id: number;
    nodeId: string;
    url: string;
    /** The comment text. */
    body: string;
    user: components["simple-user"] | null;
    createdAt: string;
    updatedAt: string;
    authorAssociation: string;
  };
  /** Gist Commit */
  gistCommit: {
    url: string;
    version: string;
    user: components["simple-user"] | null;
    changeStatus: {
      total?: number;
      additions?: number;
      deletions?: number;
    };
    committedAt: string;
  };
  /** Gitignore Template */
  gitignoreTemplate: {
    name: string;
    source: string;
  };
  /** Issues are a great way to keep track of tasks, enhancements, and bugs for your projects. */
  issue: {
    id: number;
    nodeId: string;
    /** URL for the issue */
    url: string;
    repositoryUrl: string;
    labelsUrl: string;
    commentsUrl: string;
    eventsUrl: string;
    htmlUrl: string;
    /** Number uniquely identifying the issue within its repository */
    number: number;
    /** State of the issue; either 'open' or 'closed' */
    state: string;
    /** Title of the issue */
    title: string;
    /** Contents of the issue */
    body?: string;
    user: components["simple-user"] | null;
    /** Labels to associate with this issue; pass one or more label names to replace the set of labels on this issue; send an empty array to clear all labels from the issue; note that the labels are silently dropped for users without push access to the repository */
    labels: (
      | string
      | {
      id?: number;
      nodeId?: string;
      url?: string;
      name?: string;
      description?: string | null;
      color?: string | null;
      default?: boolean;
    }
      )[];
    assignee: components["simple-user"] | null;
    assignees?: components["simple-user"][] | null;
    milestone: components["milestone"] | null;
    locked: boolean;
    activeLockReason?: string | null;
    comments: number;
    pullRequest?: {
      mergedAt?: string | null;
      diffUrl: string | null;
      htmlUrl: string | null;
      patchUrl: string | null;
      url: string | null;
    };
    closedAt: string | null;
    createdAt: string;
    updatedAt: string;
    closedBy?: components["simple-user"] | null;
    bodyHtml?: string;
    bodyText?: string;
    timelineUrl?: string;
    repository?: components["repository"];
    performedViaGithubApp?: components["integration"] | null;
    authorAssociation: string;
    reactions?: components["reaction-rollup"];
  };
  /** License */
  license: {
    key: string;
    name: string;
    spdxId: string | null;
    url: string | null;
    nodeId: string;
    htmlUrl: string;
    description: string;
    implementation: string;
    permissions: string[];
    conditions: string[];
    limitations: string[];
    body: string;
    featured: boolean;
  };
  /** Marketplace Listing Plan */
  marketplaceListingPlan: {
    url: string;
    accountsUrl: string;
    id: number;
    number: number;
    name: string;
    description: string;
    monthlyPriceInCents: number;
    yearlyPriceInCents: number;
    priceModel: string;
    hasFreeTrial: boolean;
    unitName: string | null;
    state: string;
    bullets: string[];
  };
  /** Marketplace Purchase */
  marketplacePurchase: {
    url: string;
    type: string;
    id: number;
    login: string;
    organizationBillingEmail?: string;
    marketplacePendingChange?: {
      isInstalled?: boolean;
      effectiveDate?: string;
      unitCount?: number | null;
      id?: number;
      plan?: components["marketplace-listing-plan"];
    } | null;
    marketplacePurchase: {
      billingCycle?: string;
      nextBillingDate?: string | null;
      isInstalled?: boolean;
      unitCount?: number | null;
      onFreeTrial?: boolean;
      freeTrialEndsOn?: string | null;
      updatedAt?: string;
      plan?: components["marketplace-listing-plan"];
    };
  };
  /** Api Overview */
  apiOverview: {
    verifiablePasswordAuthentication: boolean;
    sshKeyFingerprints?: {
      MD5RSA?: string;
      MD5DSA?: string;
      SHA256RSA?: string;
      SHA256DSA?: string;
    };
    hooks?: string[];
    web?: string[];
    api?: string[];
    git?: string[];
    pages?: string[];
    importer?: string[];
    githubServicesSha?: string;
    installedVersion?: string;
  };
  /** Minimal Repository */
  minimalRepository: {
    id: number;
    nodeId: string;
    name: string;
    fullName: string;
    owner: components["simple-user"] | null;
    private: boolean;
    htmlUrl: string;
    description: string | null;
    fork: boolean;
    url: string;
    archiveUrl: string;
    assigneesUrl: string;
    blobsUrl: string;
    branchesUrl: string;
    collaboratorsUrl: string;
    commentsUrl: string;
    commitsUrl: string;
    compareUrl: string;
    contentsUrl: string;
    contributorsUrl: string;
    deploymentsUrl: string;
    downloadsUrl: string;
    eventsUrl: string;
    forksUrl: string;
    gitCommitsUrl: string;
    gitRefsUrl: string;
    gitTagsUrl: string;
    gitUrl?: string;
    issueCommentUrl: string;
    issueEventsUrl: string;
    issuesUrl: string;
    keysUrl: string;
    labelsUrl: string;
    languagesUrl: string;
    mergesUrl: string;
    milestonesUrl: string;
    notificationsUrl: string;
    pullsUrl: string;
    releasesUrl: string;
    sshUrl?: string;
    stargazersUrl: string;
    statusesUrl: string;
    subscribersUrl: string;
    subscriptionUrl: string;
    tagsUrl: string;
    teamsUrl: string;
    treesUrl: string;
    cloneUrl?: string;
    mirrorUrl?: string | null;
    hooksUrl: string;
    svnUrl?: string;
    homepage?: string | null;
    language?: string | null;
    forksCount?: number;
    stargazersCount?: number;
    watchersCount?: number;
    size?: number;
    defaultBranch?: string;
    openIssuesCount?: number;
    isTemplate?: boolean;
    topics?: string[];
    hasIssues?: boolean;
    hasProjects?: boolean;
    hasWiki?: boolean;
    hasPages?: boolean;
    hasDownloads?: boolean;
    archived?: boolean;
    disabled?: boolean;
    visibility?: string;
    pushedAt?: string | null;
    createdAt?: string | null;
    updatedAt?: string | null;
    permissions?: {
      admin?: boolean;
      push?: boolean;
      pull?: boolean;
    };
    templateRepository?: string;
    tempCloneToken?: string;
    deleteBranchOnMerge?: boolean;
    subscribersCount?: number;
    networkCount?: number;
    license?: {
      key?: string;
      name?: string;
      spdxId?: string;
      url?: string;
      nodeId?: string;
    } | null;
    forks?: number;
    openIssues?: number;
    watchers?: number;
  };
  /** Thread */
  thread: {
    id?: string;
    repository?: components["minimal-repository"];
    subject?: {
      title?: string;
      url?: string;
      latestCommentUrl?: string;
      type?: string;
    };
    reason?: string;
    unread?: boolean;
    updatedAt?: string;
    lastReadAt?: string | null;
    url?: string;
    subscriptionUrl?: string;
  };
  /** Thread Subscription */
  threadSubscription: {
    subscribed: boolean;
    ignored: boolean;
    reason: string | null;
    createdAt: string | null;
    url: string;
    threadUrl?: string;
    repositoryUrl?: string;
  };
  /** Organization Full */
  organizationFull: {
    login: string;
    id: number;
    nodeId: string;
    url: string;
    reposUrl: string;
    eventsUrl: string;
    hooksUrl: string;
    issuesUrl: string;
    membersUrl: string;
    publicMembersUrl: string;
    avatarUrl: string;
    description: string | null;
    name?: string;
    company?: string;
    blog?: string;
    location?: string;
    email?: string;
    twitterUsername?: string | null;
    isVerified?: boolean;
    hasOrganizationProjects: boolean;
    hasRepositoryProjects: boolean;
    publicRepos: number;
    publicGists: number;
    followers: number;
    following: number;
    htmlUrl: string;
    createdAt: string;
    type: string;
    totalPrivateRepos?: number;
    ownedPrivateRepos?: number;
    privateGists?: number | null;
    diskUsage?: number | null;
    collaborators?: number | null;
    billingEmail?: string | null;
    plan?: {
      name: string;
      space: number;
      privateRepos: number;
      filledSeats?: number;
      seats?: number;
    };
    defaultRepositoryPermission?: string | null;
    membersCanCreateRepositories?: boolean | null;
    twoFactorRequirementEnabled?: boolean | null;
    membersAllowedRepositoryCreationType?: string;
    membersCanCreatePublicRepositories?: boolean;
    membersCanCreatePrivateRepositories?: boolean;
    membersCanCreateInternalRepositories?: boolean;
    membersCanCreatePages?: boolean;
    updatedAt: string;
  };
  /** The policy that controls the repositories in the organization that are allowed to run GitHub Actions. Can be one of: `all`, `none`, or `selected`. */
  enabledRepositories: "all" | "none" | "selected";
  actionsOrganizationPermissions: {
    enabledRepositories?: components["enabled-repositories"];
    /** The API URL to use to get or set the selected repositories that are allowed to run GitHub Actions, when `enabled_repositories` is set to `selected`. */
    selectedRepositoriesUrl?: string;
    allowedActions?: components["allowed-actions"];
    selectedActionsUrl?: components["selected-actions-url"];
  };
  runnerGroupsOrg: {
    id?: number;
    name?: string;
    visibility?: string;
    default?: boolean;
    selectedRepositoriesUrl?: string;
    runnersUrl?: string;
    inherited?: boolean;
  };
  /** Secrets for GitHub Actions for an organization. */
  organizationActionsSecret: {
    /** The name of the secret. */
    name: string;
    createdAt: string;
    updatedAt: string;
    /** Visibility of a secret */
    visibility: "all" | "private" | "selected";
    selectedRepositoriesUrl?: string;
  };
  /** The public key used for setting Actions Secrets. */
  actionsPublicKey: {
    /** The identifier for the key. */
    keyId: string;
    /** The Base64 encoded public key. */
    key: string;
    id?: number;
    url?: string;
    title?: string;
    createdAt?: string;
  };
  /** Credential Authorization */
  credentialAuthorization: {
    /** User login that owns the underlying credential. */
    login: string;
    /** Unique identifier for the credential. */
    credentialId: number;
    /** Human-readable description of the credential type. */
    credentialType: string;
    /** Last eight characters of the credential. Only included in responses with credential_type of personal access token. */
    tokenLastEight?: string;
    /** Date when the credential was authorized for use. */
    credentialAuthorizedAt: string;
    /** List of oauth scopes the token has been granted. */
    scopes?: string[];
    /** Unique string to distinguish the credential. Only included in responses with credential_type of SSH Key. */
    fingerprint?: string;
    /** Date when the credential was last accessed. May be null if it was never accessed */
    credentialAccessedAt?: string | null;
  };
  /** Org Hook */
  orgHook: {
    id: number;
    url: string;
    pingUrl: string;
    name: string;
    events: string[];
    active: boolean;
    config: {
      url?: string;
      insecureSsl?: string;
      contentType?: string;
      secret?: string;
    };
    updatedAt: string;
    createdAt: string;
    type: string;
  };
  /** Interaction limit settings. */
  interactionLimit: {
    /** The interaction limit to enable. */
    limit: "existing_users" | "contributors_only" | "collaborators_only";
    origin: string;
    expiresAt: string;
  };
  /** Organization Invitation */
  organizationInvitation: {
    id?: number;
    login?: string | null;
    email?: string | null;
    role?: string;
    createdAt?: string;
    inviter?: components["simple-user"];
    teamCount?: number;
    invitationTeamUrl?: string;
    nodeId?: string;
    invitationTeamsUrl?: string;
  };
  /** Groups of organization members that gives permissions on specified repositories. */
  teamSimple: {
    /** Unique identifier of the team */
    id: number;
    nodeId: string;
    /** URL for the team */
    url: string;
    membersUrl: string;
    /** Name of the team */
    name: string;
    /** Description of the team */
    description: string | null;
    /** Permission that the team will have for its repositories */
    permission: string;
    /** The level of privacy this team should have */
    privacy?: string;
    htmlUrl: string;
    repositoriesUrl: string;
    slug: string;
    /** Distinguished Name (DN) that team maps to within LDAP environment */
    ldapDn?: string;
  } | null;
  /** Groups of organization members that gives permissions on specified repositories. */
  team: {
    id: number;
    nodeId: string;
    name: string;
    slug: string;
    description: string | null;
    privacy?: string;
    permission: string;
    url: string;
    htmlUrl: string;
    membersUrl: string;
    repositoriesUrl: string;
    parent?: components["team-simple"] | null;
  };
  /** Org Membership */
  orgMembership: {
    url: string;
    state: string;
    role: string;
    organizationUrl: string;
    organization: components["organization-simple"];
    user: components["simple-user"] | null;
    permissions?: {
      canCreateRepository: boolean;
    };
  };
  /** A migration. */
  migration: {
    id: number;
    owner: components["simple-user"] | null;
    guid: string;
    state: string;
    lockRepositories: boolean;
    excludeAttachments: boolean;
    repositories: components["repository"][];
    url: string;
    createdAt: string;
    updatedAt: string;
    nodeId: string;
    archiveUrl?: string;
    exclude?: { [key: string]: any }[];
  };
  /** Projects are a way to organize columns and cards of work. */
  project: {
    ownerUrl: string;
    url: string;
    htmlUrl: string;
    columnsUrl: string;
    id: number;
    nodeId: string;
    /** Name of the project */
    name: string;
    /** Body of the project */
    body: string | null;
    number: number;
    /** State of the project; either 'open' or 'closed' */
    state: string;
    creator: components["simple-user"] | null;
    createdAt: string;
    updatedAt: string;
    /** The baseline permission that all organization members have on this project */
    organizationPermission?: "read" | "write" | "admin" | "none";
    /** Whether or not this project can be seen by everyone. */
    private?: boolean;
    cardsUrl?: string;
    permissions?: {
      read: boolean;
      write: boolean;
      admin: boolean;
    };
  };
  /** External Groups to be mapped to a team for membership */
  groupMapping: {
    /** Array of groups to be mapped to this team */
    groups?: {
      /** The ID of the group */
      groupId: string;
      /** The name of the group */
      groupName: string;
      /** a description of the group */
      groupDescription: string;
    }[];
    /** The ID of the group */
    groupId?: string;
    /** The name of the group */
    groupName?: string;
    /** a description of the group */
    groupDescription?: string;
    /** synchronization status for this group mapping */
    status?: string;
    /** the time of the last sync for this group-mapping */
    syncedAt?: string;
  };
  /** Groups of organization members that gives permissions on specified repositories. */
  teamFull: {
    /** Unique identifier of the team */
    id: number;
    nodeId: string;
    /** URL for the team */
    url: string;
    htmlUrl: string;
    /** Name of the team */
    name: string;
    slug: string;
    description: string | null;
    /** The level of privacy this team should have */
    privacy?: "closed" | "secret";
    /** Permission that the team will have for its repositories */
    permission: string;
    membersUrl: string;
    repositoriesUrl: string;
    parent?: components["team-simple"] | null;
    membersCount: number;
    reposCount: number;
    createdAt: string;
    updatedAt: string;
    organization: components["organization-full"];
    /** Distinguished Name (DN) that team maps to within LDAP environment */
    ldapDn?: string;
  };
  /** A team discussion is a persistent record of a free-form conversation within a team. */
  teamDiscussion: {
    author: components["simple-user"] | null;
    /** The main text of the discussion. */
    body: string;
    bodyHtml: string;
    /** The current version of the body content. If provided, this update operation will be rejected if the given version does not match the latest version on the server. */
    bodyVersion: string;
    commentsCount: number;
    commentsUrl: string;
    createdAt: string;
    lastEditedAt: string | null;
    htmlUrl: string;
    nodeId: string;
    /** The unique sequence number of a team discussion. */
    number: number;
    /** Whether or not this discussion should be pinned for easy retrieval. */
    pinned: boolean;
    /** Whether or not this discussion should be restricted to team members and organization administrators. */
    private: boolean;
    teamUrl: string;
    /** The title of the discussion. */
    title: string;
    updatedAt: string;
    url: string;
    reactions?: components["reaction-rollup"];
  };
  /** A reply to a discussion within a team. */
  teamDiscussionComment: {
    author: components["simple-user"] | null;
    /** The main text of the comment. */
    body: string;
    bodyHtml: string;
    /** The current version of the body content. If provided, this update operation will be rejected if the given version does not match the latest version on the server. */
    bodyVersion: string;
    createdAt: string;
    lastEditedAt: string | null;
    discussionUrl: string;
    htmlUrl: string;
    nodeId: string;
    /** The unique sequence number of a team discussion comment. */
    number: number;
    updatedAt: string;
    url: string;
    reactions?: components["reaction-rollup"];
  };
  /** Reactions to conversations provide a way to help people express their feelings more simply and effectively. */
  reaction: {
    id: number;
    nodeId: string;
    user: components["simple-user"] | null;
    /** The reaction to use */
    content:
      | "+1"
      | "-1"
      | "laugh"
      | "confused"
      | "heart"
      | "hooray"
      | "rocket"
      | "eyes";
    createdAt: string;
  };
  /** Team Membership */
  teamMembership: {
    url: string;
    /** The role of the user in the team. */
    role: "member" | "maintainer";
    state: string;
  };
  /** A team's access to a project. */
  teamProject: {
    ownerUrl?: string;
    url?: string;
    htmlUrl?: string;
    columnsUrl?: string;
    id?: number;
    nodeId?: string;
    name?: string;
    body?: string | null;
    number?: number;
    state?: string;
    creator?: components["simple-user"];
    createdAt?: string;
    updatedAt?: string;
    organizationPermission?: string;
    private?: boolean;
    permissions?: {
      read?: boolean;
      write?: boolean;
      admin?: boolean;
    };
  };
  /** A team's access to a repository. */
  teamRepository: {
    /** Unique identifier of the repository */
    id: number;
    nodeId: string;
    /** The name of the repository. */
    name: string;
    fullName: string;
    license: components["license-simple"] | null;
    forks: number;
    permissions?: {
      admin: boolean;
      pull: boolean;
      triage?: boolean;
      push: boolean;
      maintain?: boolean;
    };
    owner: components["simple-user"] | null;
    /** Whether the repository is private or public. */
    private: boolean;
    htmlUrl: string;
    description: string | null;
    fork: boolean;
    url: string;
    archiveUrl: string;
    assigneesUrl: string;
    blobsUrl: string;
    branchesUrl: string;
    collaboratorsUrl: string;
    commentsUrl: string;
    commitsUrl: string;
    compareUrl: string;
    contentsUrl: string;
    contributorsUrl: string;
    deploymentsUrl: string;
    downloadsUrl: string;
    eventsUrl: string;
    forksUrl: string;
    gitCommitsUrl: string;
    gitRefsUrl: string;
    gitTagsUrl: string;
    gitUrl: string;
    issueCommentUrl: string;
    issueEventsUrl: string;
    issuesUrl: string;
    keysUrl: string;
    labelsUrl: string;
    languagesUrl: string;
    mergesUrl: string;
    milestonesUrl: string;
    notificationsUrl: string;
    pullsUrl: string;
    releasesUrl: string;
    sshUrl: string;
    stargazersUrl: string;
    statusesUrl: string;
    subscribersUrl: string;
    subscriptionUrl: string;
    tagsUrl: string;
    teamsUrl: string;
    treesUrl: string;
    cloneUrl: string;
    mirrorUrl: string | null;
    hooksUrl: string;
    svnUrl: string;
    homepage: string | null;
    language: string | null;
    forksCount: number;
    stargazersCount: number;
    watchersCount: number;
    size: number;
    /** The default branch of the repository. */
    defaultBranch: string;
    openIssuesCount: number;
    /** Whether this repository acts as a template that can be used to generate new repositories. */
    isTemplate?: boolean;
    topics?: string[];
    /** Whether issues are enabled. */
    hasIssues: boolean;
    /** Whether projects are enabled. */
    hasProjects: boolean;
    /** Whether the wiki is enabled. */
    hasWiki: boolean;
    hasPages: boolean;
    /** Whether downloads are enabled. */
    hasDownloads: boolean;
    /** Whether the repository is archived. */
    archived: boolean;
    /** Returns whether or not this repository disabled. */
    disabled: boolean;
    /** The repository visibility: public, private, or internal. */
    visibility?: string;
    pushedAt: string | null;
    createdAt: string | null;
    updatedAt: string | null;
    /** Whether to allow rebase merges for pull requests. */
    allowRebaseMerge?: boolean;
    templateRepository?: {
      id?: number;
      nodeId?: string;
      name?: string;
      fullName?: string;
      owner?: {
        login?: string;
        id?: number;
        nodeId?: string;
        avatarUrl?: string;
        gravatarId?: string;
        url?: string;
        htmlUrl?: string;
        followersUrl?: string;
        followingUrl?: string;
        gistsUrl?: string;
        starredUrl?: string;
        subscriptionsUrl?: string;
        organizationsUrl?: string;
        reposUrl?: string;
        eventsUrl?: string;
        receivedEventsUrl?: string;
        type?: string;
        siteAdmin?: boolean;
      };
      private?: boolean;
      htmlUrl?: string;
      description?: string;
      fork?: boolean;
      url?: string;
      archiveUrl?: string;
      assigneesUrl?: string;
      blobsUrl?: string;
      branchesUrl?: string;
      collaboratorsUrl?: string;
      commentsUrl?: string;
      commitsUrl?: string;
      compareUrl?: string;
      contentsUrl?: string;
      contributorsUrl?: string;
      deploymentsUrl?: string;
      downloadsUrl?: string;
      eventsUrl?: string;
      forksUrl?: string;
      gitCommitsUrl?: string;
      gitRefsUrl?: string;
      gitTagsUrl?: string;
      gitUrl?: string;
      issueCommentUrl?: string;
      issueEventsUrl?: string;
      issuesUrl?: string;
      keysUrl?: string;
      labelsUrl?: string;
      languagesUrl?: string;
      mergesUrl?: string;
      milestonesUrl?: string;
      notificationsUrl?: string;
      pullsUrl?: string;
      releasesUrl?: string;
      sshUrl?: string;
      stargazersUrl?: string;
      statusesUrl?: string;
      subscribersUrl?: string;
      subscriptionUrl?: string;
      tagsUrl?: string;
      teamsUrl?: string;
      treesUrl?: string;
      cloneUrl?: string;
      mirrorUrl?: string;
      hooksUrl?: string;
      svnUrl?: string;
      homepage?: string;
      language?: string;
      forksCount?: number;
      stargazersCount?: number;
      watchersCount?: number;
      size?: number;
      defaultBranch?: string;
      openIssuesCount?: number;
      isTemplate?: boolean;
      topics?: string[];
      hasIssues?: boolean;
      hasProjects?: boolean;
      hasWiki?: boolean;
      hasPages?: boolean;
      hasDownloads?: boolean;
      archived?: boolean;
      disabled?: boolean;
      visibility?: string;
      pushedAt?: string;
      createdAt?: string;
      updatedAt?: string;
      permissions?: {
        admin?: boolean;
        push?: boolean;
        pull?: boolean;
      };
      allowRebaseMerge?: boolean;
      templateRepository?: string;
      tempCloneToken?: string;
      allowSquashMerge?: boolean;
      deleteBranchOnMerge?: boolean;
      allowMergeCommit?: boolean;
      subscribersCount?: number;
      networkCount?: number;
    } | null;
    tempCloneToken?: string;
    /** Whether to allow squash merges for pull requests. */
    allowSquashMerge?: boolean;
    /** Whether to delete head branches when pull requests are merged */
    deleteBranchOnMerge?: boolean;
    /** Whether to allow merge commits for pull requests. */
    allowMergeCommit?: boolean;
    subscribersCount?: number;
    networkCount?: number;
    openIssues: number;
    watchers: number;
    masterBranch?: string;
  };
  /** Project cards represent a scope of work. */
  projectCard: {
    url: string;
    /** The project card's ID */
    id: number;
    nodeId: string;
    note: string | null;
    creator: components["simple-user"] | null;
    createdAt: string;
    updatedAt: string;
    /** Whether or not the card is archived */
    archived?: boolean;
    columnUrl: string;
    contentUrl?: string;
    projectUrl: string;
  };
  /** Project columns contain cards of work. */
  projectColumn: {
    url: string;
    projectUrl: string;
    cardsUrl: string;
    /** The unique identifier of the project column */
    id: number;
    nodeId: string;
    /** Name of the project column */
    name: string;
    createdAt: string;
    updatedAt: string;
  };
  /** Repository Collaborator Permission */
  repositoryCollaboratorPermission: {
    permission: string;
    user: components["simple-user"] | null;
  };
  rateLimit: {
    limit: number;
    remaining: number;
    reset: number;
  };
  /** Rate Limit Overview */
  rateLimitOverview: {
    resources: {
      core: components["rate-limit"];
      graphql?: components["rate-limit"];
      search: components["rate-limit"];
      sourceImport?: components["rate-limit"];
      integrationManifest?: components["rate-limit"];
      codeScanningUpload?: components["rate-limit"];
    };
    rate: components["rate-limit"];
  };
  /** Full Repository */
  fullRepository: {
    id: number;
    nodeId: string;
    name: string;
    fullName: string;
    owner: components["simple-user"] | null;
    private: boolean;
    htmlUrl: string;
    description: string | null;
    fork: boolean;
    url: string;
    archiveUrl: string;
    assigneesUrl: string;
    blobsUrl: string;
    branchesUrl: string;
    collaboratorsUrl: string;
    commentsUrl: string;
    commitsUrl: string;
    compareUrl: string;
    contentsUrl: string;
    contributorsUrl: string;
    deploymentsUrl: string;
    downloadsUrl: string;
    eventsUrl: string;
    forksUrl: string;
    gitCommitsUrl: string;
    gitRefsUrl: string;
    gitTagsUrl: string;
    gitUrl: string;
    issueCommentUrl: string;
    issueEventsUrl: string;
    issuesUrl: string;
    keysUrl: string;
    labelsUrl: string;
    languagesUrl: string;
    mergesUrl: string;
    milestonesUrl: string;
    notificationsUrl: string;
    pullsUrl: string;
    releasesUrl: string;
    sshUrl: string;
    stargazersUrl: string;
    statusesUrl: string;
    subscribersUrl: string;
    subscriptionUrl: string;
    tagsUrl: string;
    teamsUrl: string;
    treesUrl: string;
    cloneUrl: string;
    mirrorUrl: string | null;
    hooksUrl: string;
    svnUrl: string;
    homepage: string | null;
    language: string | null;
    forksCount: number;
    stargazersCount: number;
    watchersCount: number;
    size: number;
    defaultBranch: string;
    openIssuesCount: number;
    isTemplate?: boolean;
    topics?: string[];
    hasIssues: boolean;
    hasProjects: boolean;
    hasWiki: boolean;
    hasPages: boolean;
    hasDownloads: boolean;
    archived: boolean;
    /** Returns whether or not this repository disabled. */
    disabled: boolean;
    /** The repository visibility: public, private, or internal. */
    visibility?: string;
    pushedAt: string;
    createdAt: string;
    updatedAt: string;
    permissions?: {
      admin: boolean;
      pull: boolean;
      push: boolean;
    };
    allowRebaseMerge?: boolean;
    templateRepository?: components["repository"] | null;
    tempCloneToken?: string | null;
    allowSquashMerge?: boolean;
    deleteBranchOnMerge?: boolean;
    allowMergeCommit?: boolean;
    subscribersCount: number;
    networkCount: number;
    license: components["license-simple"] | null;
    organization?: components["simple-user"] | null;
    parent?: components["repository"];
    source?: components["repository"];
    forks: number;
    masterBranch?: string;
    openIssues: number;
    watchers: number;
    /** Whether anonymous git access is allowed. */
    anonymousAccessEnabled?: boolean;
  };
  /** An artifact */
  artifact: {
    id: number;
    nodeId: string;
    /** The name of the artifact. */
    name: string;
    /** The size in bytes of the artifact. */
    sizeInBytes: number;
    url: string;
    archiveDownloadUrl: string;
    /** Whether or not the artifact has expired. */
    expired: boolean;
    createdAt: string | null;
    expiresAt: string;
    updatedAt: string | null;
  };
  /** Information of a job execution in a workflow run */
  job: {
    /** The id of the job. */
    id: number;
    /** The id of the associated workflow run. */
    runId: number;
    runUrl: string;
    nodeId: string;
    /** The SHA of the commit that is being run. */
    headSha: string;
    url: string;
    htmlUrl: string | null;
    /** The phase of the lifecycle that the job is currently in. */
    status: "queued" | "in_progress" | "completed";
    /** The outcome of the job. */
    conclusion: string | null;
    /** The time that the job started, in ISO 8601 format. */
    startedAt: string;
    /** The time that the job finished, in ISO 8601 format. */
    completedAt: string | null;
    /** The name of the job. */
    name: string;
    /** Steps in this job. */
    steps?: {
      /** The phase of the lifecycle that the job is currently in. */
      status: "queued" | "in_progress" | "completed";
      /** The outcome of the job. */
      conclusion: string | null;
      /** The name of the job. */
      name: string;
      number: number;
      /** The time that the step started, in ISO 8601 format. */
      startedAt?: string | null;
      /** The time that the job finished, in ISO 8601 format. */
      completedAt?: string | null;
    }[];
    checkRunUrl: string;
  };
  /** Whether GitHub Actions is enabled on the repository. */
  actionsEnabled: boolean;
  actionsRepositoryPermissions: {
    enabled?: components["actions-enabled"];
    allowedActions?: components["allowed-actions"];
    selectedActionsUrl?: components["selected-actions-url"];
  };
  pullRequestMinimal: {
    id: number;
    number: number;
    url: string;
    head: {
      ref: string;
      sha: string;
      repo: {
        id: number;
        url: string;
        name: string;
      };
    };
    base: {
      ref: string;
      sha: string;
      repo: {
        id: number;
        url: string;
        name: string;
      };
    };
  };
  /** Simple Commit */
  simpleCommit: {
    id: string;
    treeId: string;
    message: string;
    timestamp: string;
    author: {
      name: string;
      email: string;
    } | null;
    committer: {
      name: string;
      email: string;
    } | null;
  };
  /** An invocation of a workflow */
  workflowRun: {
    /** The ID of the workflow run. */
    id: number;
    /** The name of the workflow run. */
    name?: string;
    nodeId: string;
    headBranch: string | null;
    /** The SHA of the head commit that points to the version of the worflow being run. */
    headSha: string;
    /** The auto incrementing run number for the workflow run. */
    runNumber: number;
    event: string;
    status: string | null;
    conclusion: string | null;
    /** The ID of the parent workflow. */
    workflowId: number;
    /** The URL to the workflow run. */
    url: string;
    htmlUrl: string;
    pullRequests: components["pull-request-minimal"][] | null;
    createdAt: string | null;
    updatedAt: string | null;
    /** The URL to the jobs for the workflow run. */
    jobsUrl: string;
    /** The URL to download the logs for the workflow run. */
    logsUrl: string;
    /** The URL to the associated check suite. */
    checkSuiteUrl: string;
    /** The URL to the artifacts for the workflow run. */
    artifactsUrl: string;
    /** The URL to cancel the workflow run. */
    cancelUrl: string;
    /** The URL to rerun the workflow run. */
    rerunUrl: string;
    /** The URL to the workflow. */
    workflowUrl: string;
    headCommit: components["simple-commit"];
    repository: components["minimal-repository"];
    headRepository: components["minimal-repository"];
    headRepositoryId?: number;
  };
  /** Workflow Run Usage */
  workflowRunUsage: {
    billable?: {
      UBUNTU?: {
        totalMs?: number;
        jobs?: number;
      };
      MACOS?: {
        totalMs?: number;
        jobs?: number;
      };
      WINDOWS?: {
        totalMs?: number;
        jobs?: number;
      };
    };
    runDurationMs?: number;
  };
  /** Set secrets for GitHub Actions. */
  actionsSecret: {
    /** The name of the secret. */
    name: string;
    createdAt: string;
    updatedAt: string;
  };
  /** A GitHub Actions workflow */
  workflow: {
    id: number;
    nodeId: string;
    name: string;
    path: string;
    state: "active" | "deleted";
    createdAt: string;
    updatedAt: string;
    url: string;
    htmlUrl: string;
    badgeUrl: string;
    deletedAt?: string;
  };
  /** Workflow Usage */
  workflowUsage: {
    billable?: {
      UBUNTU?: {
        totalMs?: number;
      };
      MACOS?: {
        totalMs?: number;
      };
      WINDOWS?: {
        totalMs?: number;
      };
    };
  };
  /** Protected Branch Admin Enforced */
  protectedBranchAdminEnforced: {
    url: string;
    enabled: boolean;
  };
  /** Protected Branch Pull Request Review */
  protectedBranchPullRequestReview: {
    url?: string;
    dismissalRestrictions?: {
      /** The list of users with review dismissal access. */
      users?: components["simple-user"][];
      /** The list of teams with review dismissal access. */
      teams?: components["team"][];
      url?: string;
      usersUrl?: string;
      teamsUrl?: string;
    };
    dismissStaleReviews: boolean;
    requireCodeOwnerReviews: boolean;
    requiredApprovingReviewCount?: number;
  };
  /** Branch Restriction Policy */
  branchRestrictionPolicy: {
    url: string;
    usersUrl: string;
    teamsUrl: string;
    appsUrl: string;
    users: {
      login?: string;
      id?: number;
      nodeId?: string;
      avatarUrl?: string;
      gravatarId?: string;
      url?: string;
      htmlUrl?: string;
      followersUrl?: string;
      followingUrl?: string;
      gistsUrl?: string;
      starredUrl?: string;
      subscriptionsUrl?: string;
      organizationsUrl?: string;
      reposUrl?: string;
      eventsUrl?: string;
      receivedEventsUrl?: string;
      type?: string;
      siteAdmin?: boolean;
    }[];
    teams: {
      id?: number;
      nodeId?: string;
      url?: string;
      htmlUrl?: string;
      name?: string;
      slug?: string;
      description?: string | null;
      privacy?: string;
      permission?: string;
      membersUrl?: string;
      repositoriesUrl?: string;
      parent?: string | null;
    }[];
    apps: {
      id?: number;
      slug?: string;
      nodeId?: string;
      owner?: {
        login?: string;
        id?: number;
        nodeId?: string;
        url?: string;
        reposUrl?: string;
        eventsUrl?: string;
        hooksUrl?: string;
        issuesUrl?: string;
        membersUrl?: string;
        publicMembersUrl?: string;
        avatarUrl?: string;
        description?: string;
        gravatarId?: string;
        htmlUrl?: string;
        followersUrl?: string;
        followingUrl?: string;
        gistsUrl?: string;
        starredUrl?: string;
        subscriptionsUrl?: string;
        organizationsUrl?: string;
        receivedEventsUrl?: string;
        type?: string;
      };
      name?: string;
      description?: string;
      externalUrl?: string;
      htmlUrl?: string;
      createdAt?: string;
      updatedAt?: string;
      permissions?: {
        metadata?: string;
        contents?: string;
        issues?: string;
        singleFile?: string;
      };
      events?: string[];
    }[];
  };
  /** Branch Protection */
  branchProtection: {
    url?: string;
    requiredStatusChecks: {
      url?: string;
      enforcementLevel: string;
      contexts: string[];
      contextsUrl?: string;
    };
    enforceAdmins?: components["protected-branch-admin-enforced"];
    requiredPullRequestReviews?: components["protected-branch-pull-request-review"];
    restrictions?: components["branch-restriction-policy"];
    requiredLinearHistory?: {
      enabled?: boolean;
    };
    allowForcePushes?: {
      enabled?: boolean;
    };
    allowDeletions?: {
      enabled?: boolean;
    };
    enabled: boolean;
    name?: string;
    protectionUrl?: string;
  };
  /** Short Branch */
  shortBranch: {
    name: string;
    commit: {
      sha: string;
      url: string;
    };
    protected: boolean;
    protection?: components["branch-protection"];
    protectionUrl?: string;
  };
  /** Metaproperties for Git author/committer information. */
  gitUser: {
    name?: string;
    email?: string;
    date?: string;
  };
  verification: {
    verified: boolean;
    reason: string;
    payload: string | null;
    signature: string | null;
  };
  /** Commit */
  commit: {
    url: string | null;
    sha: string | null;
    nodeId: string;
    htmlUrl: string;
    commentsUrl: string;
    commit: {
      url: string;
      author: components["git-user"] | null;
      committer: components["git-user"] | null;
      message: string;
      commentCount: number;
      tree: {
        sha: string;
        url: string;
      };
      verification?: components["verification"];
    };
    author: components["simple-user"] | null;
    committer: components["simple-user"] | null;
    parents: {
      sha: string;
      url: string;
      htmlUrl?: string;
    }[];
    stats?: {
      additions?: number;
      deletions?: number;
      total?: number;
    };
    files?: {
      filename?: string;
      additions?: number;
      deletions?: number;
      changes?: number;
      status?: string;
      rawUrl?: string;
      blobUrl?: string;
      patch?: string;
      sha?: string;
      contentsUrl?: string;
      previousFilename?: string;
    }[];
  };
  /** Branch With Protection */
  branchWithProtection: {
    name: string;
    commit: components["commit"];
    Links: {
      html: string;
      self: string;
    };
    protected: boolean;
    protection: components["branch-protection"];
    protectionUrl: string;
    pattern?: string;
    requiredApprovingReviewCount?: number;
  };
  /** Status Check Policy */
  statusCheckPolicy: {
    url: string;
    strict: boolean;
    contexts: string[];
    contextsUrl: string;
  };
  /** Branch protections protect branches */
  protectedBranch: {
    url: string;
    requiredStatusChecks?: components["status-check-policy"];
    requiredPullRequestReviews?: {
      url: string;
      dismissStaleReviews?: boolean;
      requireCodeOwnerReviews?: boolean;
      requiredApprovingReviewCount?: number;
      dismissalRestrictions?: {
        url: string;
        usersUrl: string;
        teamsUrl: string;
        users: components["simple-user"][];
        teams: components["team"][];
      };
    };
    requiredSignatures?: {
      url: string;
      enabled: boolean;
    };
    enforceAdmins?: {
      url: string;
      enabled: boolean;
    };
    requiredLinearHistory?: {
      enabled: boolean;
    };
    allowForcePushes?: {
      enabled: boolean;
    };
    allowDeletions?: {
      enabled: boolean;
    };
    restrictions?: components["branch-restriction-policy"];
  };
  /** A check performed on the code of a given code change */
  checkRun: {
    /** The id of the check. */
    id: number;
    /** The SHA of the commit that is being checked. */
    headSha: string;
    nodeId: string;
    externalId: string | null;
    url: string;
    htmlUrl: string | null;
    detailsUrl: string | null;
    /** The phase of the lifecycle that the check is currently in. */
    status: "queued" | "in_progress" | "completed";
    conclusion: string | null;
    startedAt: string | null;
    completedAt: string | null;
    output: {
      title: string | null;
      summary: string | null;
      text: string | null;
      annotationsCount: number;
      annotationsUrl: string;
    };
    /** The name of the check. */
    name: string;
    checkSuite: {
      id: number;
    } | null;
    app: components["integration"] | null;
    pullRequests: components["pull-request-minimal"][];
  };
  /** Check Annotation */
  checkAnnotation: {
    path: string;
    startLine: number;
    endLine: number;
    startColumn: number | null;
    endColumn: number | null;
    annotationLevel: string | null;
    title: string | null;
    message: string | null;
    rawDetails: string | null;
    blobHref: string;
  };
  /** A suite of checks performed on the code of a given code change */
  checkSuite: {
    id: number;
    nodeId: string;
    headBranch: string | null;
    /** The SHA of the head commit that is being checked. */
    headSha: string;
    status: string | null;
    conclusion: string | null;
    url: string | null;
    before: string | null;
    after: string | null;
    pullRequests: components["pull-request-minimal"][] | null;
    app: components["integration"] | null;
    repository: components["minimal-repository"];
    createdAt: string | null;
    updatedAt: string | null;
    headCommit: components["simple-commit"];
    latestCheckRunsCount: number;
    checkRunsUrl: string;
  };
  /** Check suite configuration preferences for a repository. */
  checkSuitePreference: {
    preferences?: {
      autoTriggerChecks?: {
        appId: number;
        setting: boolean;
      }[];
    };
    repository?: components["repository"];
  };
  /** State of a code scanning alert. */
  codeScanningAlertState: "open" | "dismissed" | "fixed";
  /** The full Git reference, formatted as `refs/heads/<branch name>`. */
  codeScanningAlertRef: string;
  /** The code scanning alert number. */
  codeScanningAlertNumber: number;
  /** The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`. */
  codeScanningAlertCreatedAt: string;
  /** The REST API URL of the alert resource. */
  codeScanningAlertUrl: string;
  /** The GitHub URL of the alert resource. */
  codeScanningAlertHtmlUrl: string;
  /** The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`. */
  codeScanningAlertDismissedAt: string | null;
  /** **Required when the state is dismissed.** The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`. */
  codeScanningAlertDismissedReason:
    | ("false positive" | "won't fix" | "used in tests")
    | null;
  codeScanningAlertRule: {
    /** A unique identifier for the rule used to detect the alert. */
    id?: string | null;
    /** The severity of the alert. */
    severity?: ("none" | "note" | "warning" | "error") | null;
    /** A short description of the rule used to detect the alert. */
    description?: string;
  };
  /** The name of the tool used to generate the code scanning analysis alert. */
  codeScanningAnalysisToolName: string;
  codeScanningAnalysisTool: {
    name?: components["code-scanning-analysis-tool-name"];
    /** The version of the tool used to detect the alert. */
    version?: string | null;
  };
  codeScanningAlertCodeScanningAlertItems: {
    number?: components["code-scanning-alert-number"];
    createdAt?: components["code-scanning-alert-created-at"];
    url?: components["code-scanning-alert-url"];
    htmlUrl?: components["code-scanning-alert-html-url"];
    state?: components["code-scanning-alert-state"];
    dismissedBy?: components["simple-user"];
    dismissedAt?: components["code-scanning-alert-dismissed-at"];
    dismissedReason?: components["code-scanning-alert-dismissed-reason"];
    rule?: components["code-scanning-alert-rule"];
    tool?: components["code-scanning-analysis-tool"];
  };
  /** Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name. */
  codeScanningAnalysisAnalysisKey: string;
  /** Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed. */
  codeScanningAlertEnvironment: string;
  codeScanningAlertInstances:
    | {
    ref?: components["code-scanning-alert-ref"];
    analysisKey?: components["code-scanning-analysis-analysis-key"];
    environment?: components["code-scanning-alert-environment"];
    matrixVars?: string | null;
    state?: components["code-scanning-alert-state"];
  }[]
    | null;
  codeScanningAlertCodeScanningAlert: {
    number?: components["code-scanning-alert-number"];
    createdAt?: components["code-scanning-alert-created-at"];
    url?: components["code-scanning-alert-url"];
    htmlUrl?: components["code-scanning-alert-html-url"];
    instances?: components["code-scanning-alert-instances"];
    state?: components["code-scanning-alert-state"];
    dismissedBy?: components["simple-user"];
    dismissedAt?: components["code-scanning-alert-dismissed-at"];
    dismissedReason?: components["code-scanning-alert-dismissed-reason"];
    rule?: components["code-scanning-alert-rule"];
    tool?: components["code-scanning-analysis-tool"];
  };
  /** Sets the state of the code scanning alert. Can be one of `open` or `dismissed`. You must provide `dismissed_reason` when you set the state to `dismissed`. */
  codeScanningAlertSetState: "open" | "dismissed";
  /** The full Git reference of the code scanning analysis file, formatted as `refs/heads/<branch name>`. */
  codeScanningAnalysisRef: string;
  /** The commit SHA of the code scanning analysis file. */
  codeScanningAnalysisCommitSha: string;
  /** The time that the analysis was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`. */
  codeScanningAnalysisCreatedAt: string;
  /** Identifies the variable values associated with the environment in which this analysis was performed. */
  codeScanningAnalysisEnvironment: string;
  codeScanningAnalysisCodeScanningAnalysis: {
    commitSha?: components["code-scanning-analysis-commit-sha"];
    ref?: components["code-scanning-analysis-ref"];
    analysisKey?: components["code-scanning-analysis-analysis-key"];
    createdAt?: components["code-scanning-analysis-created-at"];
    toolName?: components["code-scanning-analysis-tool-name"];
    error?: string;
    environment?: components["code-scanning-analysis-environment"];
  };
  /** A Base64 string representing the SARIF file to upload. You must first compress your SARIF file using [`gzip`](http://www.gnu.org/software/gzip/manual/gzip.html) and then translate the contents of the file into a Base64 encoding string. */
  codeScanningAnalysisSarifFile: string;
  /** Collaborator */
  collaborator: {
    login: string;
    id: number;
    nodeId: string;
    avatarUrl: string;
    gravatarId: string | null;
    url: string;
    htmlUrl: string;
    followersUrl: string;
    followingUrl: string;
    gistsUrl: string;
    starredUrl: string;
    subscriptionsUrl: string;
    organizationsUrl: string;
    reposUrl: string;
    eventsUrl: string;
    receivedEventsUrl: string;
    type: string;
    siteAdmin: boolean;
    permissions?: {
      pull: boolean;
      push: boolean;
      admin: boolean;
    };
  };
  /** Repository invitations let you manage who you collaborate with. */
  repositoryInvitation: {
    /** Unique identifier of the repository invitation. */
    id: number;
    repository: components["minimal-repository"];
    invitee: components["simple-user"] | null;
    inviter: components["simple-user"] | null;
    /** The permission associated with the invitation. */
    permissions: "read" | "write" | "admin";
    createdAt: string;
    /** URL for the repository invitation */
    url: string;
    htmlUrl: string;
    nodeId: string;
  };
  /** Commit Comment */
  commitComment: {
    htmlUrl: string;
    url: string;
    id: number;
    nodeId: string;
    body: string;
    path: string | null;
    position: number | null;
    line: number | null;
    commitId: string;
    user: components["simple-user"] | null;
    createdAt: string;
    updatedAt: string;
    authorAssociation: string;
    reactions?: components["reaction-rollup"];
  };
  /** Scim Error */
  scimError: {
    message?: string | null;
    documentationUrl?: string | null;
    detail?: string | null;
    status?: number;
    scimType?: string | null;
    schemas?: string[];
  };
  /** Branch Short */
  branchShort: {
    name?: string;
    commit?: {
      sha?: string;
      url?: string;
    };
    protected?: boolean;
  };
  /** Hypermedia Link */
  link: {
    href: string;
  };
  /** Pull Request Simple */
  pullRequestSimple: {
    url: string;
    id: number;
    nodeId: string;
    htmlUrl: string;
    diffUrl: string;
    patchUrl: string;
    issueUrl: string;
    commitsUrl: string;
    reviewCommentsUrl: string;
    reviewCommentUrl: string;
    commentsUrl: string;
    statusesUrl: string;
    number: number;
    state: string;
    locked: boolean;
    title: string;
    user: components["simple-user"] | null;
    body: string | null;
    labels: {
      id?: number;
      nodeId?: string;
      url?: string;
      name?: string;
      description?: string;
      color?: string;
      default?: boolean;
    }[];
    milestone: components["milestone"] | null;
    activeLockReason?: string | null;
    createdAt: string;
    updatedAt: string;
    closedAt: string | null;
    mergedAt: string | null;
    mergeCommitSha: string | null;
    assignee: components["simple-user"] | null;
    assignees?: components["simple-user"][] | null;
    requestedReviewers?: components["simple-user"][] | null;
    requestedTeams?: components["team-simple"][] | null;
    head: {
      label: string;
      ref: string;
      repo: components["repository"];
      sha: string;
      user: components["simple-user"] | null;
    };
    base: {
      label: string;
      ref: string;
      repo: components["repository"];
      sha: string;
      user: components["simple-user"] | null;
    };
    Links: {
      comments: components["link"];
      commits: components["link"];
      statuses: components["link"];
      html: components["link"];
      issue: components["link"];
      reviewComments: components["link"];
      reviewComment: components["link"];
      self: components["link"];
    };
    authorAssociation: string;
    /** Indicates whether or not the pull request is a draft. */
    draft?: boolean;
  };
  simpleCommitStatus: {
    description: string | null;
    id: number;
    nodeId: string;
    state: string;
    context: string;
    targetUrl: string;
    required?: boolean | null;
    avatarUrl: string | null;
    url: string;
    createdAt: string;
    updatedAt: string;
  };
  /** Combined Commit Status */
  combinedCommitStatus: {
    state: string;
    statuses: components["simple-commit-status"][];
    sha: string;
    totalCount: number;
    repository: components["minimal-repository"];
    commitUrl: string;
    url: string;
  };
  /** The status of a commit. */
  status: {
    url?: string;
    avatarUrl?: string | null;
    id?: number;
    nodeId?: string;
    state?: string;
    description?: string;
    targetUrl?: string;
    context?: string;
    createdAt?: string;
    updatedAt?: string;
    creator?: components["simple-user"];
  };
  /** Code of Conduct Simple */
  codeOfConductSimple: {
    url: string;
    key: string;
    name: string;
    htmlUrl: string | null;
  };
  communityHealthFile: {
    url: string;
    htmlUrl: string;
  };
  /** Community Profile */
  communityProfile: {
    healthPercentage: number;
    description: string | null;
    documentation: string | null;
    files: {
      codeOfConduct: components["code-of-conduct-simple"] | null;
      license: components["license-simple"] | null;
      contributing: components["community-health-file"] | null;
      readme: components["community-health-file"] | null;
      issueTemplate: components["community-health-file"] | null;
      pullRequestTemplate: components["community-health-file"] | null;
    };
    updatedAt: string | null;
  };
  /** Diff Entry */
  diffEntry: {
    sha: string;
    filename: string;
    status: string;
    additions: number;
    deletions: number;
    changes: number;
    blobUrl: string;
    rawUrl: string;
    contentsUrl: string;
    patch?: string;
    previousFilename?: string;
  };
  /** Commit Comparison */
  commitComparison: {
    url: string;
    htmlUrl: string;
    permalinkUrl: string;
    diffUrl: string;
    patchUrl: string;
    baseCommit: components["commit"];
    mergeBaseCommit: components["commit"];
    status: "diverged" | "ahead" | "behind" | "identical";
    aheadBy: number;
    behindBy: number;
    totalCommits: number;
    commits: components["commit"][];
    files: components["diff-entry"][];
  };
  /** Content Tree */
  contentTree: {
    type: string;
    size: number;
    name: string;
    path: string;
    sha: string;
    url: string;
    gitUrl: string | null;
    htmlUrl: string | null;
    downloadUrl: string | null;
    entries?: {
      type: string;
      size: number;
      name: string;
      path: string;
      content?: string;
      sha: string;
      url: string;
      gitUrl: string | null;
      htmlUrl: string | null;
      downloadUrl: string | null;
      Links: {
        git: string | null;
        html: string | null;
        self: string;
      };
    }[];
    Links: {
      git: string | null;
      html: string | null;
      self: string;
    };
  };
  /** A list of directory items */
  contentDirectory: {
    type: string;
    size: number;
    name: string;
    path: string;
    content?: string;
    sha: string;
    url: string;
    gitUrl: string | null;
    htmlUrl: string | null;
    downloadUrl: string | null;
    Links: {
      git: string | null;
      html: string | null;
      self: string;
    };
  }[];
  /** Content File */
  contentFile: {
    type: string;
    encoding: string;
    size: number;
    name: string;
    path: string;
    content: string;
    sha: string;
    url: string;
    gitUrl: string | null;
    htmlUrl: string | null;
    downloadUrl: string | null;
    Links: {
      git: string | null;
      html: string | null;
      self: string;
    };
    target?: string;
    submoduleGitUrl?: string;
  };
  /** An object describing a symlink */
  contentSymlink: {
    type: string;
    target: string;
    size: number;
    name: string;
    path: string;
    sha: string;
    url: string;
    gitUrl: string | null;
    htmlUrl: string | null;
    downloadUrl: string | null;
    Links: {
      git: string | null;
      html: string | null;
      self: string;
    };
  };
  /** An object describing a symlink */
  contentSubmodule: {
    type: string;
    submoduleGitUrl: string;
    size: number;
    name: string;
    path: string;
    sha: string;
    url: string;
    gitUrl: string | null;
    htmlUrl: string | null;
    downloadUrl: string | null;
    Links: {
      git: string | null;
      html: string | null;
      self: string;
    };
  };
  /** File Commit */
  fileCommit: {
    content?: {
      name?: string;
      path?: string;
      sha?: string;
      size?: number;
      url?: string;
      htmlUrl?: string;
      gitUrl?: string;
      downloadUrl?: string;
      type?: string;
      Links?: {
        self?: string;
        git?: string;
        html?: string;
      };
    } | null;
    commit?: {
      sha?: string;
      nodeId?: string;
      url?: string;
      htmlUrl?: string;
      author?: {
        date?: string;
        name?: string;
        email?: string;
      };
      committer?: {
        date?: string;
        name?: string;
        email?: string;
      };
      message?: string;
      tree?: {
        url?: string;
        sha?: string;
      };
      parents?: {
        url?: string;
        htmlUrl?: string;
        sha?: string;
      }[];
      verification?: {
        verified?: boolean;
        reason?: string;
        signature?: string | null;
        payload?: string | null;
      };
    };
  };
  /** Contributor */
  contributor: {
    login?: string;
    id?: number;
    nodeId?: string;
    avatarUrl?: string;
    gravatarId?: string | null;
    url?: string;
    htmlUrl?: string;
    followersUrl?: string;
    followingUrl?: string;
    gistsUrl?: string;
    starredUrl?: string;
    subscriptionsUrl?: string;
    organizationsUrl?: string;
    reposUrl?: string;
    eventsUrl?: string;
    receivedEventsUrl?: string;
    type: string;
    siteAdmin?: boolean;
    contributions: number;
    email?: string;
    name?: string;
  };
  /** A request for a specific ref(branch,sha,tag) to be deployed */
  deployment: {
    url: string;
    /** Unique identifier of the deployment */
    id: number;
    nodeId: string;
    sha: string;
    /** The ref to deploy. This can be a branch, tag, or sha. */
    ref: string;
    /** Parameter to specify a task to execute */
    task: string;
    payload: { [key: string]: any };
    originalEnvironment?: string;
    /** Name for the target deployment environment. */
    environment: string;
    description: string | null;
    creator: components["simple-user"] | null;
    createdAt: string;
    updatedAt: string;
    statusesUrl: string;
    repositoryUrl: string;
    /** Specifies if the given environment is will no longer exist at some point in the future. Default: false. */
    transientEnvironment?: boolean;
    /** Specifies if the given environment is one that end-users directly interact with. Default: false. */
    productionEnvironment?: boolean;
    performedViaGithubApp?: components["integration"] | null;
  };
  /** The status of a deployment. */
  deploymentStatus: {
    url: string;
    id: number;
    nodeId: string;
    /** The state of the status. */
    state:
      | "error"
      | "failure"
      | "inactive"
      | "pending"
      | "success"
      | "queued"
      | "in_progress";
    creator: components["simple-user"] | null;
    /** A short description of the status. */
    description: string;
    /** The environment of the deployment that the status is for. */
    environment?: string;
    /** Deprecated: the URL to associate with this status. */
    targetUrl: string;
    createdAt: string;
    updatedAt: string;
    deploymentUrl: string;
    repositoryUrl: string;
    /** The URL for accessing your environment. */
    environmentUrl?: string;
    /** The URL to associate with this status. */
    logUrl?: string;
    performedViaGithubApp?: components["integration"] | null;
  };
  /** Short Blob */
  shortBlob: {
    url?: string;
    sha?: string;
  };
  /** Blob */
  blob: {
    content: string;
    encoding: string;
    url: string;
    sha: string;
    size: number | null;
    nodeId: string;
    highlightedContent?: string;
  };
  /** Low-level Git commit operations within a repository */
  gitCommit: {
    /** SHA for the commit */
    sha?: string;
    nodeId?: string;
    url?: string;
    /** Identifying information for the git-user */
    author?: {
      /** Timestamp of the commit */
      date?: string;
      /** Git email address of the user */
      email: string;
      /** Name of the git user */
      name: string;
    };
    /** Identifying information for the git-user */
    committer?: {
      /** Timestamp of the commit */
      date?: string;
      /** Git email address of the user */
      email: string;
      /** Name of the git user */
      name: string;
    };
    /** Message describing the purpose of the commit */
    message?: string;
    tree?: {
      /** SHA for the commit */
      sha?: string;
      url?: string;
    };
    parents?: {
      /** SHA for the commit */
      sha?: string;
      url?: string;
      htmlUrl?: string;
    }[];
    verification?: {
      verified?: boolean;
      reason?: string;
      signature?: string | null;
      payload?: string | null;
    };
    htmlUrl?: string;
  };
  /** Git references within a repository */
  gitRef: {
    ref?: string;
    nodeId?: string;
    url?: string;
    object?: {
      type?: string;
      /** SHA for the reference */
      sha?: string;
      url?: string;
    };
  };
  /** Metadata for a Git tag */
  gitTag: {
    nodeId: string;
    /** Name of the tag */
    tag: string;
    sha: string;
    /** URL for the tag */
    url: string;
    /** Message describing the purpose of the tag */
    message: string;
    tagger: {
      date: string;
      email: string;
      name: string;
    };
    object: {
      sha: string;
      type: string;
      url: string;
    };
    verification?: components["verification"];
  };
  /** The hierarchy between files in a Git repository. */
  gitTree: {
    sha: string;
    url: string;
    truncated: boolean;
    /** Objects specifying a tree structure */
    tree: {
      path?: string;
      mode?: string;
      type?: string;
      sha?: string;
      size?: number;
      url?: string;
    }[];
  };
  hookResponse: {
    code: number | null;
    status: string | null;
    message: string | null;
  };
  /** Webhooks for repositories. */
  hook: {
    type: string;
    /** Unique identifier of the webhook. */
    id: number;
    /** The name of a valid service, use 'web' for a webhook. */
    name: string;
    /** Determines whether the hook is actually triggered on pushes. */
    active: boolean;
    /** Determines what events the hook is triggered for. Default: ['push']. */
    events: string[];
    config: {
      email?: string;
      password?: string;
      room?: string;
      subdomain?: string;
      url?: components["webhook-config-url"];
      insecureSsl?: components["webhook-config-insecure-ssl"];
      contentType?: components["webhook-config-content-type"];
      digest?: string;
      secret?: components["webhook-config-secret"];
      token?: string;
    };
    updatedAt: string;
    createdAt: string;
    url: string;
    testUrl: string;
    pingUrl: string;
    lastResponse: components["hook-response"];
  };
  /** A repository import from an external source. */
  import: {
    vcs: string | null;
    useLfs?: string;
    /** The URL of the originating repository. */
    vcsUrl: string;
    svcRoot?: string;
    tfvcProject?: string;
    status:
      | "auth"
      | "error"
      | "none"
      | "detecting"
      | "choose"
      | "auth_failed"
      | "importing"
      | "mapping"
      | "waiting_to_push"
      | "pushing"
      | "complete"
      | "setup"
      | "unknown"
      | "detection_found_multiple"
      | "detection_found_nothing"
      | "detection_needs_auth";
    statusText?: string | null;
    failedStep?: string | null;
    errorMessage?: string | null;
    importPercent?: number | null;
    commitCount?: number | null;
    pushPercent?: number | null;
    hasLargeFiles?: boolean;
    largeFilesSize?: number;
    largeFilesCount?: number;
    projectChoices?: {
      vcs?: string;
      tfvcProject?: string;
      humanName?: string;
    }[];
    message?: string;
    authorsCount?: number | null;
    url: string;
    htmlUrl: string;
    authorsUrl: string;
    repositoryUrl: string;
    svnRoot?: string;
  };
  /** Porter Author */
  porterAuthor: {
    id: number;
    remoteId: string;
    remoteName: string;
    email: string;
    name: string;
    url: string;
    importUrl: string;
  };
  /** Porter Large File */
  porterLargeFile: {
    refName: string;
    path: string;
    oid: string;
    size: number;
  };
  /** Issue Event Label */
  issueEventLabel: {
    name: string | null;
    color: string | null;
  };
  issueEventDismissedReview: {
    state: string;
    reviewId: number;
    dismissalMessage: string | null;
    dismissalCommitId?: string | null;
  };
  /** Issue Event Milestone */
  issueEventMilestone: {
    title: string;
  };
  /** Issue Event Project Card */
  issueEventProjectCard: {
    url: string;
    id: number;
    projectUrl: string;
    projectId: number;
    columnName: string;
    previousColumnName?: string;
  };
  /** Issue Event Rename */
  issueEventRename: {
    from: string;
    to: string;
  };
  /** Issue Event */
  issueEvent: {
    id: number;
    nodeId: string;
    url: string;
    actor: components["simple-user"] | null;
    event: string;
    commitId: string | null;
    commitUrl: string | null;
    createdAt: string;
    issue?: components["issue-simple"];
    label?: components["issue-event-label"];
    assignee?: components["simple-user"] | null;
    assigner?: components["simple-user"] | null;
    reviewRequester?: components["simple-user"] | null;
    requestedReviewer?: components["simple-user"] | null;
    requestedTeam?: components["team"];
    dismissedReview?: components["issue-event-dismissed-review"];
    milestone?: components["issue-event-milestone"];
    projectCard?: components["issue-event-project-card"];
    rename?: components["issue-event-rename"];
    authorAssociation?: string;
    lockReason?: string | null;
  };
  /** Issue Event for Issue */
  issueEventForIssue: {
    id?: number;
    nodeId?: string;
    url?: string;
    actor?: components["simple-user"];
    event?: string;
    commitId?: string | null;
    commitUrl?: string | null;
    createdAt?: string;
    sha?: string;
    htmlUrl?: string;
    message?: string;
    issueUrl?: string;
    updatedAt?: string;
    authorAssociation?: string;
    body?: string;
    lockReason?: string;
    submittedAt?: string;
    state?: string;
    pullRequestUrl?: string;
    bodyHtml?: string;
    bodyText?: string;
  };
  /** Color-coded labels help you categorize and filter your issues (just like labels in Gmail). */
  label: {
    id: number;
    nodeId: string;
    /** URL for the label */
    url: string;
    /** The name of the label. */
    name: string;
    description?: string | null;
    /** 6-character hex code, without the leading #, identifying the color */
    color: string;
    default: boolean;
  };
  /** An SSH key granting access to a single repository. */
  deployKey: {
    id?: number;
    key?: string;
    url?: string;
    title?: string;
    verified?: boolean;
    createdAt?: string;
    readOnly?: boolean;
  };
  /** Language */
  language: { [key: string]: number };
  /** License Content */
  licenseContent: {
    name: string;
    path: string;
    sha: string;
    size: number;
    url: string;
    htmlUrl: string | null;
    gitUrl: string | null;
    downloadUrl: string | null;
    type: string;
    content: string;
    encoding: string;
    Links: {
      git: string | null;
      html: string | null;
      self: string;
    };
    license: components["license-simple"] | null;
  };
  pagesSourceHash: {
    branch: string;
    path: string;
  };
  /** The configuration for GitHub Pages for a repository. */
  page: {
    /** The API address for accessing this Page resource. */
    url: string;
    /** The status of the most recent build of the Page. */
    status: ("built" | "building" | "errored") | null;
    /** The Pages site's custom domain */
    cname: string | null;
    /** Whether the Page has a custom 404 page. */
    custom_404: boolean;
    /** The web address the Page can be accessed from. */
    htmlUrl?: string;
    source?: components["pages-source-hash"];
  };
  /** Page Build */
  pageBuild: {
    url: string;
    status: string;
    error: {
      message: string | null;
    };
    pusher: components["simple-user"] | null;
    commit: string;
    duration: number;
    createdAt: string;
    updatedAt: string;
  };
  /** Page Build Status */
  pageBuildStatus: {
    url: string;
    status: string;
  };
  /** Pull requests let you tell others about changes you've pushed to a repository on GitHub. Once a pull request is sent, interested parties can review the set of changes, discuss potential modifications, and even push follow-up commits if necessary. */
  pullRequest: {
    url: string;
    id: number;
    nodeId: string;
    htmlUrl: string;
    diffUrl: string;
    patchUrl: string;
    issueUrl: string;
    commitsUrl: string;
    reviewCommentsUrl: string;
    reviewCommentUrl: string;
    commentsUrl: string;
    statusesUrl: string;
    /** Number uniquely identifying the pull request within its repository. */
    number: number;
    /** State of this Pull Request. Either `open` or `closed`. */
    state: "open" | "closed";
    locked: boolean;
    /** The title of the pull request. */
    title: string;
    user: components["simple-user"] | null;
    body: string | null;
    labels: {
      id?: number;
      nodeId?: string;
      url?: string;
      name?: string;
      description?: string | null;
      color?: string;
      default?: boolean;
    }[];
    milestone: components["milestone"] | null;
    activeLockReason?: string | null;
    createdAt: string;
    updatedAt: string;
    closedAt: string | null;
    mergedAt: string | null;
    mergeCommitSha: string | null;
    assignee: components["simple-user"] | null;
    assignees?: components["simple-user"][] | null;
    requestedReviewers?: components["simple-user"][] | null;
    requestedTeams?: components["team-simple"][] | null;
    head: {
      label: string;
      ref: string;
      repo: {
        archiveUrl: string;
        assigneesUrl: string;
        blobsUrl: string;
        branchesUrl: string;
        collaboratorsUrl: string;
        commentsUrl: string;
        commitsUrl: string;
        compareUrl: string;
        contentsUrl: string;
        contributorsUrl: string;
        deploymentsUrl: string;
        description: string | null;
        downloadsUrl: string;
        eventsUrl: string;
        fork: boolean;
        forksUrl: string;
        fullName: string;
        gitCommitsUrl: string;
        gitRefsUrl: string;
        gitTagsUrl: string;
        hooksUrl: string;
        htmlUrl: string;
        id: number;
        nodeId: string;
        issueCommentUrl: string;
        issueEventsUrl: string;
        issuesUrl: string;
        keysUrl: string;
        labelsUrl: string;
        languagesUrl: string;
        mergesUrl: string;
        milestonesUrl: string;
        name: string;
        notificationsUrl: string;
        owner: {
          avatarUrl: string;
          eventsUrl: string;
          followersUrl: string;
          followingUrl: string;
          gistsUrl: string;
          gravatarId: string | null;
          htmlUrl: string;
          id: number;
          nodeId: string;
          login: string;
          organizationsUrl: string;
          receivedEventsUrl: string;
          reposUrl: string;
          siteAdmin: boolean;
          starredUrl: string;
          subscriptionsUrl: string;
          type: string;
          url: string;
        };
        private: boolean;
        pullsUrl: string;
        releasesUrl: string;
        stargazersUrl: string;
        statusesUrl: string;
        subscribersUrl: string;
        subscriptionUrl: string;
        tagsUrl: string;
        teamsUrl: string;
        treesUrl: string;
        url: string;
        cloneUrl: string;
        defaultBranch: string;
        forks: number;
        forksCount: number;
        gitUrl: string;
        hasDownloads: boolean;
        hasIssues: boolean;
        hasProjects: boolean;
        hasWiki: boolean;
        hasPages: boolean;
        homepage: string | null;
        language: string | null;
        masterBranch?: string;
        archived: boolean;
        disabled: boolean;
        mirrorUrl: string | null;
        openIssues: number;
        openIssuesCount: number;
        permissions?: {
          admin: boolean;
          pull: boolean;
          push: boolean;
        };
        tempCloneToken?: string;
        allowMergeCommit?: boolean;
        allowSquashMerge?: boolean;
        allowRebaseMerge?: boolean;
        license: {
          key: string;
          name: string;
          url: string | null;
          spdxId: string | null;
          nodeId: string;
        } | null;
        pushedAt: string;
        size: number;
        sshUrl: string;
        stargazersCount: number;
        svnUrl: string;
        topics?: string[];
        watchers: number;
        watchersCount: number;
        createdAt: string;
        updatedAt: string;
      };
      sha: string;
      user: {
        avatarUrl: string;
        eventsUrl: string;
        followersUrl: string;
        followingUrl: string;
        gistsUrl: string;
        gravatarId: string | null;
        htmlUrl: string;
        id: number;
        nodeId: string;
        login: string;
        organizationsUrl: string;
        receivedEventsUrl: string;
        reposUrl: string;
        siteAdmin: boolean;
        starredUrl: string;
        subscriptionsUrl: string;
        type: string;
        url: string;
      };
    };
    base: {
      label: string;
      ref: string;
      repo: {
        archiveUrl: string;
        assigneesUrl: string;
        blobsUrl: string;
        branchesUrl: string;
        collaboratorsUrl: string;
        commentsUrl: string;
        commitsUrl: string;
        compareUrl: string;
        contentsUrl: string;
        contributorsUrl: string;
        deploymentsUrl: string;
        description: string | null;
        downloadsUrl: string;
        eventsUrl: string;
        fork: boolean;
        forksUrl: string;
        fullName: string;
        gitCommitsUrl: string;
        gitRefsUrl: string;
        gitTagsUrl: string;
        hooksUrl: string;
        htmlUrl: string;
        id: number;
        nodeId: string;
        issueCommentUrl: string;
        issueEventsUrl: string;
        issuesUrl: string;
        keysUrl: string;
        labelsUrl: string;
        languagesUrl: string;
        mergesUrl: string;
        milestonesUrl: string;
        name: string;
        notificationsUrl: string;
        owner: {
          avatarUrl: string;
          eventsUrl: string;
          followersUrl: string;
          followingUrl: string;
          gistsUrl: string;
          gravatarId: string | null;
          htmlUrl: string;
          id: number;
          nodeId: string;
          login: string;
          organizationsUrl: string;
          receivedEventsUrl: string;
          reposUrl: string;
          siteAdmin: boolean;
          starredUrl: string;
          subscriptionsUrl: string;
          type: string;
          url: string;
        };
        private: boolean;
        pullsUrl: string;
        releasesUrl: string;
        stargazersUrl: string;
        statusesUrl: string;
        subscribersUrl: string;
        subscriptionUrl: string;
        tagsUrl: string;
        teamsUrl: string;
        treesUrl: string;
        url: string;
        cloneUrl: string;
        defaultBranch: string;
        forks: number;
        forksCount: number;
        gitUrl: string;
        hasDownloads: boolean;
        hasIssues: boolean;
        hasProjects: boolean;
        hasWiki: boolean;
        hasPages: boolean;
        homepage: string | null;
        language: string | null;
        masterBranch?: string;
        archived: boolean;
        disabled: boolean;
        mirrorUrl: string | null;
        openIssues: number;
        openIssuesCount: number;
        permissions?: {
          admin: boolean;
          pull: boolean;
          push: boolean;
        };
        tempCloneToken?: string;
        allowMergeCommit?: boolean;
        allowSquashMerge?: boolean;
        allowRebaseMerge?: boolean;
        license: components["license-simple"] | null;
        pushedAt: string;
        size: number;
        sshUrl: string;
        stargazersCount: number;
        svnUrl: string;
        topics?: string[];
        watchers: number;
        watchersCount: number;
        createdAt: string;
        updatedAt: string;
      };
      sha: string;
      user: {
        avatarUrl: string;
        eventsUrl: string;
        followersUrl: string;
        followingUrl: string;
        gistsUrl: string;
        gravatarId: string | null;
        htmlUrl: string;
        id: number;
        nodeId: string;
        login: string;
        organizationsUrl: string;
        receivedEventsUrl: string;
        reposUrl: string;
        siteAdmin: boolean;
        starredUrl: string;
        subscriptionsUrl: string;
        type: string;
        url: string;
      };
    };
    Links: {
      comments: components["link"];
      commits: components["link"];
      statuses: components["link"];
      html: components["link"];
      issue: components["link"];
      reviewComments: components["link"];
      reviewComment: components["link"];
      self: components["link"];
    };
    authorAssociation: string;
    /** Indicates whether or not the pull request is a draft. */
    draft?: boolean;
    merged: boolean;
    mergeable: boolean | null;
    rebaseable?: boolean | null;
    mergeableState: string;
    mergedBy: components["simple-user"] | null;
    comments: number;
    reviewComments: number;
    /** Indicates whether maintainers can modify the pull request. */
    maintainerCanModify: boolean;
    commits: number;
    additions: number;
    deletions: number;
    changedFiles: number;
  };
  /** Pull Request Review Comments are comments on a portion of the Pull Request's diff. */
  pullRequestReviewComment: {
    /** URL for the pull request review comment */
    url: string;
    /** The ID of the pull request review to which the comment belongs. */
    pullRequestReviewId: number | null;
    /** The ID of the pull request review comment. */
    id: number;
    /** The node ID of the pull request review comment. */
    nodeId: string;
    /** The diff of the line that the comment refers to. */
    diffHunk: string;
    /** The relative path of the file to which the comment applies. */
    path: string;
    /** The line index in the diff to which the comment applies. */
    position: number;
    /** The index of the original line in the diff to which the comment applies. */
    originalPosition: number;
    /** The SHA of the commit to which the comment applies. */
    commitId: string;
    /** The SHA of the original commit to which the comment applies. */
    originalCommitId: string;
    /** The comment ID to reply to. */
    inReplyToId?: number;
    user: components["simple-user"];
    /** The text of the comment. */
    body: string;
    createdAt: string;
    updatedAt: string;
    /** HTML URL for the pull request review comment. */
    htmlUrl: string;
    /** URL for the pull request that the review comment belongs to. */
    pullRequestUrl: string;
    /** How the author of the comment is associated with the pull request. */
    authorAssociation: string;
    Links: {
      self: {
        href: string;
      };
      html: {
        href: string;
      };
      pullRequest: {
        href: string;
      };
    };
    /** The first line of the range for a multi-line comment. */
    startLine?: number | null;
    /** The first line of the range for a multi-line comment. */
    originalStartLine?: number | null;
    /** The side of the first line of the range for a multi-line comment. */
    startSide?: ("LEFT" | "RIGHT") | null;
    /** The line of the blob to which the comment applies. The last line of the range for a multi-line comment */
    line?: number;
    /** The line of the blob to which the comment applies. The last line of the range for a multi-line comment */
    originalLine?: number;
    /** The side of the diff to which the comment applies. The side of the last line of the range for a multi-line comment */
    side?: "LEFT" | "RIGHT";
    reactions?: components["reaction-rollup"];
    bodyHtml?: string;
    bodyText?: string;
  };
  /** Pull Request Merge Result */
  pullRequestMergeResult: {
    sha: string;
    merged: boolean;
    message: string;
  };
  /** Pull Request Review Request */
  pullRequestReviewRequest: {
    users?: {
      login?: string;
      id?: number;
      nodeId?: string;
      avatarUrl?: string;
      gravatarId?: string;
      url?: string;
      htmlUrl?: string;
      followersUrl?: string;
      followingUrl?: string;
      gistsUrl?: string;
      starredUrl?: string;
      subscriptionsUrl?: string;
      organizationsUrl?: string;
      reposUrl?: string;
      eventsUrl?: string;
      receivedEventsUrl?: string;
      type?: string;
      siteAdmin?: boolean;
    }[];
    teams?: {
      id?: number;
      nodeId?: string;
      url?: string;
      htmlUrl?: string;
      name?: string;
      slug?: string;
      description?: string | null;
      privacy?: string;
      permission?: string;
      membersUrl?: string;
      repositoriesUrl?: string;
      parent?: string | null;
    }[];
  };
  /** Pull Request Reviews are reviews on pull requests. */
  pullRequestReview: {
    /** Unique identifier of the review */
    id: number;
    nodeId: string;
    user: components["simple-user"] | null;
    /** The text of the review. */
    body: string;
    state: string;
    htmlUrl: string;
    pullRequestUrl: string;
    Links: {
      html: {
        href: string;
      };
      pullRequest: {
        href: string;
      };
    };
    submittedAt?: string;
    /** A commit SHA for the review. */
    commitId: string;
    bodyHtml?: string;
    bodyText?: string;
    authorAssociation: string;
  };
  /** Legacy Review Comment */
  reviewComment: {
    url: string;
    pullRequestReviewId: number | null;
    id: number;
    nodeId: string;
    diffHunk: string;
    path: string;
    position: number | null;
    originalPosition: number;
    commitId: string;
    originalCommitId: string;
    inReplyToId?: number;
    user: components["simple-user"] | null;
    body: string;
    createdAt: string;
    updatedAt: string;
    htmlUrl: string;
    pullRequestUrl: string;
    authorAssociation: string;
    Links: {
      self: components["link"];
      html: components["link"];
      pullRequest: components["link"];
    };
    bodyText?: string;
    bodyHtml?: string;
    /** The side of the first line of the range for a multi-line comment. */
    side?: "LEFT" | "RIGHT";
    /** The side of the first line of the range for a multi-line comment. */
    startSide?: ("LEFT" | "RIGHT") | null;
    /** The line of the blob to which the comment applies. The last line of the range for a multi-line comment */
    line?: number;
    /** The original line of the blob to which the comment applies. The last line of the range for a multi-line comment */
    originalLine?: number;
    /** The first line of the range for a multi-line comment. */
    startLine?: number | null;
    /** The original first line of the range for a multi-line comment. */
    originalStartLine?: number | null;
  };
  /** Data related to a release. */
  releaseAsset: {
    url: string;
    browserDownloadUrl: string;
    id: number;
    nodeId: string;
    /** The file name of the asset. */
    name: string;
    label: string | null;
    /** State of the release asset. */
    state: "uploaded";
    contentType: string;
    size: number;
    downloadCount: number;
    createdAt: string;
    updatedAt: string;
    uploader: components["simple-user"] | null;
  };
  /** A release. */
  release: {
    url: string;
    htmlUrl: string;
    assetsUrl: string;
    uploadUrl: string;
    tarballUrl: string | null;
    zipballUrl: string | null;
    id: number;
    nodeId: string;
    /** The name of the tag. */
    tagName: string;
    /** Specifies the commitish value that determines where the Git tag is created from. */
    targetCommitish: string;
    name: string | null;
    body?: string | null;
    /** true to create a draft (unpublished) release, false to create a published one. */
    draft: boolean;
    /** Whether to identify the release as a prerelease or a full release. */
    prerelease: boolean;
    createdAt: string;
    publishedAt: string | null;
    author: components["simple-user"];
    assets: components["release-asset"][];
    bodyHtml?: string;
    bodyText?: string;
  };
  /** Stargazer */
  stargazer: {
    starredAt: string;
    user: components["simple-user"] | null;
  };
  /** Code Frequency Stat */
  codeFrequencyStat: number[];
  /** Commit Activity */
  commitActivity: {
    days: number[];
    total: number;
    week: number;
  };
  /** Contributor Activity */
  contributorActivity: {
    author: components["simple-user"] | null;
    total: number;
    weeks: {
      w?: string;
      a?: number;
      d?: number;
      c?: number;
    }[];
  };
  participationStats: {
    all?: number[];
    owner?: number[];
  };
  /** Repository invitations let you manage who you collaborate with. */
  repositorySubscription: {
    /** Determines if notifications should be received from this repository. */
    subscribed: boolean;
    /** Determines if all notifications should be blocked from this repository. */
    ignored: boolean;
    reason: string | null;
    createdAt: string;
    url: string;
    repositoryUrl: string;
  };
  /** Tag */
  tag: {
    name: string;
    commit: {
      sha: string;
      url: string;
    };
    zipballUrl: string;
    tarballUrl: string;
    nodeId: string;
  };
  /** A topic aggregates entities that are related to a subject. */
  topic: {
    names?: string[];
  };
  traffic: {
    timestamp: string;
    uniques: number;
    count: number;
  };
  /** Clone Traffic */
  cloneTraffic: {
    count: number;
    uniques: number;
    clones: components["traffic"][];
  };
  /** Content Traffic */
  contentTraffic: {
    path: string;
    title: string;
    count: number;
    uniques: number;
  };
  /** Referrer Traffic */
  referrerTraffic: {
    referrer: string;
    count: number;
    uniques: number;
  };
  /** View Traffic */
  viewTraffic: {
    count: number;
    uniques: number;
    views: components["traffic"][];
  };
  scimGroupListEnterprise: {
    schemas?: string[];
    totalResults?: number;
    itemsPerPage?: number;
    startIndex?: number;
    Resources?: {
      schemas?: string[];
      id?: string;
      externalId?: string | null;
      displayName?: string;
      members?: {
        value?: string;
        $ref?: string;
        display?: string;
      }[];
      meta?: {
        resourceType?: string;
        created?: string;
        lastModified?: string;
        location?: string;
      };
    }[];
  };
  scimEnterpriseGroup: {
    schemas?: string[];
    id?: string;
    externalId?: string | null;
    displayName?: string;
    members?: {
      value?: string;
      $ref?: string;
      display?: string;
    }[];
    meta?: {
      resourceType?: string;
      created?: string;
      lastModified?: string;
      location?: string;
    };
  };
  scimUserListEnterprise: {
    schemas?: string[];
    totalResults?: number;
    itemsPerPage?: number;
    startIndex?: number;
    Resources?: {
      schemas?: string[];
      id?: string;
      externalId?: string;
      userName?: string;
      name?: {
        givenName?: string;
        familyName?: string;
      };
      emails?: {
        value?: string;
        primary?: boolean;
        type?: string;
      }[];
      groups?: {
        value?: string;
      }[];
      active?: boolean;
      meta?: {
        resourceType?: string;
        created?: string;
        lastModified?: string;
        location?: string;
      };
    }[];
  };
  scimEnterpriseUser: {
    schemas?: string[];
    id?: string;
    externalId?: string;
    userName?: string;
    name?: {
      givenName?: string;
      familyName?: string;
    };
    emails?: {
      value?: string;
      type?: string;
      primary?: boolean;
    }[];
    groups?: {
      value?: string;
    }[];
    active?: boolean;
    meta?: {
      resourceType?: string;
      created?: string;
      lastModified?: string;
      location?: string;
    };
  };
  /** SCIM /Users provisioning endpoints */
  scimUser: {
    /** SCIM schema used. */
    schemas: string[];
    /** Unique identifier of an external identity */
    id: string;
    /** The ID of the User. */
    externalId: string | null;
    /** Configured by the admin. Could be an email, login, or username */
    userName: string | null;
    /** The name of the user, suitable for display to end-users */
    displayName?: string | null;
    name: {
      givenName: string | null;
      familyName: string | null;
      formatted?: string | null;
    };
    /** user emails */
    emails: {
      value: string;
      primary?: boolean;
    }[];
    /** The active status of the User. */
    active: boolean;
    meta: {
      resourceType?: string;
      created?: string;
      lastModified?: string;
      location?: string;
    };
    /** The ID of the organization. */
    organizationId?: number;
    /** Set of operations to be performed */
    operations?: {
      op: "add" | "remove" | "replace";
      path?: string;
      value?: string | { [key: string]: any } | { [key: string]: any }[];
    }[];
    /** associated groups */
    groups?: {
      value?: string;
      display?: string;
    }[];
  };
  /** SCIM User List */
  scimUserList: {
    /** SCIM schema used. */
    schemas: string[];
    totalResults: number;
    itemsPerPage: number;
    startIndex: number;
    Resources: components["scim-user"][];
  };
  searchResultTextMatches: {
    objectUrl?: string;
    objectType?: string | null;
    property?: string;
    fragment?: string;
    matches?: {
      text?: string;
      indices?: number[];
    }[];
  }[];
  /** Code Search Result Item */
  codeSearchResultItem: {
    name: string;
    path: string;
    sha: string;
    url: string;
    gitUrl: string;
    htmlUrl: string;
    repository: components["minimal-repository"];
    score: number;
    fileSize?: number;
    language?: string | null;
    lastModifiedAt?: string;
    lineNumbers?: string[];
    textMatches?: components["search-result-text-matches"];
  };
  /** Commit Search Result Item */
  commitSearchResultItem: {
    url: string;
    sha: string;
    htmlUrl: string;
    commentsUrl: string;
    commit: {
      author: {
        name: string;
        email: string;
        date: string;
      };
      committer: components["git-user"] | null;
      commentCount: number;
      message: string;
      tree: {
        sha: string;
        url: string;
      };
      url: string;
      verification?: components["verification"];
    };
    author: components["simple-user"] | null;
    committer: components["git-user"] | null;
    parents: {
      url?: string;
      htmlUrl?: string;
      sha?: string;
    }[];
    repository: components["minimal-repository"];
    score: number;
    nodeId: string;
    textMatches?: components["search-result-text-matches"];
  };
  /** Issue Search Result Item */
  issueSearchResultItem: {
    url: string;
    repositoryUrl: string;
    labelsUrl: string;
    commentsUrl: string;
    eventsUrl: string;
    htmlUrl: string;
    id: number;
    nodeId: string;
    number: number;
    title: string;
    locked: boolean;
    activeLockReason?: string | null;
    assignees?: components["simple-user"][] | null;
    user: components["simple-user"] | null;
    labels: {
      id?: number;
      nodeId?: string;
      url?: string;
      name?: string;
      color?: string;
      default?: boolean;
      description?: string | null;
    }[];
    state: string;
    assignee: components["simple-user"] | null;
    milestone: components["milestone"] | null;
    comments: number;
    createdAt: string;
    updatedAt: string;
    closedAt: string | null;
    textMatches?: components["search-result-text-matches"];
    pullRequest?: {
      mergedAt?: string | null;
      diffUrl: string | null;
      htmlUrl: string | null;
      patchUrl: string | null;
      url: string | null;
    };
    body?: string;
    score: number;
    authorAssociation: string;
    draft?: boolean;
    repository?: components["repository"];
    bodyHtml?: string;
    bodyText?: string;
    timelineUrl?: string;
    performedViaGithubApp?: components["integration"] | null;
  };
  /** Label Search Result Item */
  labelSearchResultItem: {
    id: number;
    nodeId: string;
    url: string;
    name: string;
    color: string;
    default: boolean;
    description: string | null;
    score: number;
    textMatches?: components["search-result-text-matches"];
  };
  /** Repo Search Result Item */
  repoSearchResultItem: {
    id: number;
    nodeId: string;
    name: string;
    fullName: string;
    owner: components["simple-user"] | null;
    private: boolean;
    htmlUrl: string;
    description: string | null;
    fork: boolean;
    url: string;
    createdAt: string;
    updatedAt: string;
    pushedAt: string;
    homepage: string | null;
    size: number;
    stargazersCount: number;
    watchersCount: number;
    language: string | null;
    forksCount: number;
    openIssuesCount: number;
    masterBranch?: string;
    defaultBranch: string;
    score: number;
    forksUrl: string;
    keysUrl: string;
    collaboratorsUrl: string;
    teamsUrl: string;
    hooksUrl: string;
    issueEventsUrl: string;
    eventsUrl: string;
    assigneesUrl: string;
    branchesUrl: string;
    tagsUrl: string;
    blobsUrl: string;
    gitTagsUrl: string;
    gitRefsUrl: string;
    treesUrl: string;
    statusesUrl: string;
    languagesUrl: string;
    stargazersUrl: string;
    contributorsUrl: string;
    subscribersUrl: string;
    subscriptionUrl: string;
    commitsUrl: string;
    gitCommitsUrl: string;
    commentsUrl: string;
    issueCommentUrl: string;
    contentsUrl: string;
    compareUrl: string;
    mergesUrl: string;
    archiveUrl: string;
    downloadsUrl: string;
    issuesUrl: string;
    pullsUrl: string;
    milestonesUrl: string;
    notificationsUrl: string;
    labelsUrl: string;
    releasesUrl: string;
    deploymentsUrl: string;
    gitUrl: string;
    sshUrl: string;
    cloneUrl: string;
    svnUrl: string;
    forks: number;
    openIssues: number;
    watchers: number;
    topics?: string[];
    mirrorUrl: string | null;
    hasIssues: boolean;
    hasProjects: boolean;
    hasPages: boolean;
    hasWiki: boolean;
    hasDownloads: boolean;
    archived: boolean;
    /** Returns whether or not this repository disabled. */
    disabled: boolean;
    license: components["license-simple"] | null;
    permissions?: {
      admin: boolean;
      pull: boolean;
      push: boolean;
    };
    textMatches?: components["search-result-text-matches"];
    tempCloneToken?: string;
    allowMergeCommit?: boolean;
    allowSquashMerge?: boolean;
    allowRebaseMerge?: boolean;
    deleteBranchOnMerge?: boolean;
  };
  /** Topic Search Result Item */
  topicSearchResultItem: {
    name: string;
    displayName: string | null;
    shortDescription: string | null;
    description: string | null;
    createdBy: string | null;
    released: string | null;
    createdAt: string;
    updatedAt: string;
    featured: boolean;
    curated: boolean;
    score: number;
    repositoryCount?: number | null;
    logoUrl?: string | null;
    textMatches?: components["search-result-text-matches"];
    related?:
      | {
      topicRelation?: {
        id?: number;
        name?: string;
        topicId?: number;
        relationType?: string;
      };
    }[]
      | null;
    aliases?:
      | {
      topicRelation?: {
        id?: number;
        name?: string;
        topicId?: number;
        relationType?: string;
      };
    }[]
      | null;
  };
  /** User Search Result Item */
  userSearchResultItem: {
    login: string;
    id: number;
    nodeId: string;
    avatarUrl: string;
    gravatarId: string | null;
    url: string;
    htmlUrl: string;
    followersUrl: string;
    subscriptionsUrl: string;
    organizationsUrl: string;
    reposUrl: string;
    receivedEventsUrl: string;
    type: string;
    score: number;
    followingUrl: string;
    gistsUrl: string;
    starredUrl: string;
    eventsUrl: string;
    publicRepos?: number;
    publicGists?: number;
    followers?: number;
    following?: number;
    createdAt?: string;
    updatedAt?: string;
    name?: string | null;
    bio?: string | null;
    email?: string | null;
    location?: string | null;
    siteAdmin: boolean;
    hireable?: boolean | null;
    textMatches?: components["search-result-text-matches"];
    blog?: string | null;
    company?: string | null;
    suspendedAt?: string | null;
  };
  /** Private User */
  privateUser: {
    login: string;
    id: number;
    nodeId: string;
    avatarUrl: string;
    gravatarId: string | null;
    url: string;
    htmlUrl: string;
    followersUrl: string;
    followingUrl: string;
    gistsUrl: string;
    starredUrl: string;
    subscriptionsUrl: string;
    organizationsUrl: string;
    reposUrl: string;
    eventsUrl: string;
    receivedEventsUrl: string;
    type: string;
    siteAdmin: boolean;
    name: string | null;
    company: string | null;
    blog: string | null;
    location: string | null;
    email: string | null;
    hireable: boolean | null;
    bio: string | null;
    twitterUsername?: string | null;
    publicRepos: number;
    publicGists: number;
    followers: number;
    following: number;
    createdAt: string;
    updatedAt: string;
    privateGists: number;
    totalPrivateRepos: number;
    ownedPrivateRepos: number;
    diskUsage: number;
    collaborators: number;
    twoFactorAuthentication: boolean;
    plan?: {
      collaborators: number;
      name: string;
      space: number;
      privateRepos: number;
    };
    suspendedAt?: string | null;
    businessPlus?: boolean;
    ldapDn?: string;
  };
  /** Public User */
  publicUser: {
    login: string;
    id: number;
    nodeId: string;
    avatarUrl: string;
    gravatarId: string | null;
    url: string;
    htmlUrl: string;
    followersUrl: string;
    followingUrl: string;
    gistsUrl: string;
    starredUrl: string;
    subscriptionsUrl: string;
    organizationsUrl: string;
    reposUrl: string;
    eventsUrl: string;
    receivedEventsUrl: string;
    type: string;
    siteAdmin: boolean;
    name: string | null;
    company: string | null;
    blog: string | null;
    location: string | null;
    email: string | null;
    hireable: boolean | null;
    bio: string | null;
    twitterUsername?: string | null;
    publicRepos: number;
    publicGists: number;
    followers: number;
    following: number;
    createdAt: string;
    updatedAt: string;
    plan?: {
      collaborators: number;
      name: string;
      space: number;
      privateRepos: number;
    };
    suspendedAt?: string | null;
    privateGists?: number;
    totalPrivateRepos?: number;
    ownedPrivateRepos?: number;
    diskUsage?: number;
    collaborators?: number;
  };
  /** Email */
  email:
    | {
    email: string;
    primary: boolean;
    verified: boolean;
    visibility: string | null;
  }
    | string;
  /** A unique encryption key */
  gpgKey: {
    id: number;
    primaryKeyId: number | null;
    keyId: string;
    publicKey: string;
    emails: {
      email?: string;
      verified?: boolean;
    }[];
    subkeys: {
      id?: number;
      primaryKeyId?: number;
      keyId?: string;
      publicKey?: string;
      emails?: { [key: string]: any }[];
      subkeys?: { [key: string]: any }[];
      canSign?: boolean;
      canEncryptComms?: boolean;
      canEncryptStorage?: boolean;
      canCertify?: boolean;
      createdAt?: string;
      expiresAt?: string | null;
      rawKey?: string | null;
    }[];
    canSign: boolean;
    canEncryptComms: boolean;
    canEncryptStorage: boolean;
    canCertify: boolean;
    createdAt: string;
    expiresAt: string | null;
    rawKey: string | null;
  };
  /** Key */
  key: {
    keyId?: string;
    key?: string;
    id?: number;
    url?: string;
    title?: string;
    createdAt?: string;
    verified?: boolean;
    readOnly?: boolean;
  };
  marketplaceAccount: {
    url: string;
    id: number;
    type: string;
    nodeId?: string;
    login: string;
    email?: string | null;
    organizationBillingEmail?: string | null;
  };
  /** User Marketplace Purchase */
  userMarketplacePurchase: {
    billingCycle: string;
    nextBillingDate: string | null;
    unitCount: number | null;
    onFreeTrial: boolean;
    freeTrialEndsOn: string | null;
    updatedAt: string | null;
    account: components["marketplace-account"];
    plan: components["marketplace-listing-plan"];
  };
  /** Starred Repository */
  starredRepository: {
    starredAt: string;
    repo: components["repository"];
  };
  /** Hovercard */
  hovercard: {
    contexts: {
      message: string;
      octicon: string;
    }[];
  };
  /** Key Simple */
  keySimple: {
    id: number;
    key: string;
  };

  responses: {
    /** Resource Not Found */
    not_found: {
      content: {
        "application/json": components["basic-error"];
      };
    };
    /** Validation Failed */
    validation_failed_simple: {
      content: {
        "application/json": components["validation-error-simple"];
      };
    };
    /** Preview Header Missing */
    preview_header_missing: {
      content: {
        "application/json": {
          message: string;
          documentationUrl: string;
        };
      };
    };
    /** Forbidden */
    forbidden: {
      content: {
        "application/json": components["basic-error"];
      };
    };
    /** Requires Authentication */
    requires_authentication: {
      content: {
        "application/json": components["basic-error"];
      };
    };
    /** Validation Failed */
    validation_failed: {
      content: {
        "application/json": components["validation-error"];
      };
    };
    /** Not Modified */
    not_modified: unknown;
    /** Gone */
    gone: {
      content: {
        "application/json": components["basic-error"];
      };
    };
    /** Service Unavailable */
    service_unavailable: {
      content: {
        "application/json": {
          code?: string;
          message?: string;
          documentationUrl?: string;
        };
      };
    };
    /** Forbidden Gist */
    forbidden_gist: {
      content: {
        "application/json": {
          block?: {
            reason?: string;
            createdAt?: string;
            htmlUrl?: string | null;
          };
          message?: string;
          documentationUrl?: string;
        };
      };
    };
    /** Moved Permanently */
    moved_permanently: unknown;
    /** Conflict */
    conflict: {
      content: {
        "application/json": components["basic-error"];
      };
    };
    /** Internal Error */
    internal_error: {
      content: {
        "application/json": components["basic-error"];
      };
    };
    /** Bad Request */
    bad_request: {
      content: {
        "application/json": components["basic-error"];
        "application/scim+json": components["scim-error"];
      };
    };
    /** Found */
    found: unknown;
    /** Resource Not Found */
    scim_not_found: {
      content: {
        "application/json": components["scim-error"];
        "application/scim+json": components["scim-error"];
      };
    };
    /** Forbidden */
    scim_forbidden: {
      content: {
        "application/json": components["scim-error"];
        "application/scim+json": components["scim-error"];
      };
    };
    /** Bad Request */
    scim_bad_request: {
      content: {
        "application/json": components["scim-error"];
        "application/scim+json": components["scim-error"];
      };
    };
    /** Internal Error */
    scim_internal_error: {
      content: {
        "application/json": components["scim-error"];
        "application/scim+json": components["scim-error"];
      };
    };
    /** Conflict */
    scim_conflict: {
      content: {
        "application/json": components["scim-error"];
        "application/scim+json": components["scim-error"];
      };
    };
  };
  parameters: {
    /** Results per page (max 100) */
    perPage: number;
    /** Page number of the results to fetch. */
    page: number;
    /** Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. */
    since: string;
    /** installation_id parameter */
    installationId: number;
    /** grant_id parameter */
    grantId: number;
    clientId: string;
    accessToken: string;
    appSlug: string;
    /** authorization_id parameter */
    authorizationId: number;
    /** The slug version of the enterprise name. You can also substitute this value with the enterprise id. */
    enterprise: string;
    /** Unique identifier of an organization. */
    orgId: number;
    /** Unique identifier of the self-hosted runner group. */
    runnerGroupId: number;
    /** Unique identifier of the self-hosted runner. */
    runnerId: number;
    /** gist_id parameter */
    gistId: string;
    /** comment_id parameter */
    commentId: number;
    /** A list of comma separated label names. Example: `bug,ui,@high` */
    labels: string;
    /** One of `asc` (ascending) or `desc` (descending). */
    direction: "asc" | "desc";
    /** account_id parameter */
    accountId: number;
    /** plan_id parameter */
    planId: number;
    /** One of `created` (when the repository was starred) or `updated` (when it was last pushed to). */
    sort: "created" | "updated";
    owner: string;
    repo: string;
    /** If `true`, show notifications marked as read. */
    all: boolean;
    /** If `true`, only shows notifications in which the user is directly participating or mentioned. */
    participating: boolean;
    /** Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. */
    before: string;
    /** thread_id parameter */
    threadId: number;
    /** An organization ID. Only return organizations with an ID greater than this ID. */
    sinceOrg: number;
    org: string;
    repositoryId: number;
    /** secret_name parameter */
    secretName: string;
    username: string;
    hookId: number;
    /** invitation_id parameter */
    invitationId: number;
    /** migration_id parameter */
    migrationId: number;
    /** repo_name parameter */
    repoName: string;
    /** team_slug parameter */
    teamSlug: string;
    discussionNumber: number;
    commentNumber: number;
    reactionId: number;
    projectId: number;
    /** card_id parameter */
    cardId: number;
    /** column_id parameter */
    columnId: number;
    /** artifact_id parameter */
    artifactId: number;
    /** job_id parameter */
    jobId: number;
    /** Returns someone's workflow runs. Use the login for the user who created the `push` associated with the check suite or workflow run. */
    actor: string;
    /** Returns workflow runs associated with a branch. Use the name of the branch of the `push`. */
    workflowRunBranch: string;
    /** Returns workflow run triggered by the event you specify. For example, `push`, `pull_request` or `issue`. For more information, see "[Events that trigger workflows](https://help.github.com/en/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)." */
    event: string;
    /** Returns workflow runs associated with the check run `status` or `conclusion` you specify. For example, a conclusion can be `success` or a status can be `completed`. For more information, see the `status` and `conclusion` options available in "[Create a check run](https://docs.github.com/rest/reference/checks#create-a-check-run)." */
    workflowRunStatus: "completed" | "status" | "conclusion";
    runId: number;
    /** The ID of the workflow. You can also pass the workflow file name as a string. */
    workflowId: number | string;
    /** branch+ parameter */
    branch: string;
    /** check_run_id parameter */
    checkRunId: number;
    /** check_suite_id parameter */
    checkSuiteId: number;
    /** Returns check runs with the specified `name`. */
    checkName: string;
    /** Returns check runs with the specified `status`. Can be one of `queued`, `in_progress`, or `completed`. */
    status: "queued" | "in_progress" | "completed";
    /** The code scanning alert number. */
    alertNumber: components["code-scanning-alert-number"];
    /** commit_sha+ parameter */
    commitSha: string;
    /** deployment_id parameter */
    deploymentId: number;
    /** A user ID. Only return users with an ID greater than this ID. */
    sinceUser: number;
    /** issue_number parameter */
    issueNumber: number;
    /** key_id parameter */
    keyId: number;
    /** milestone_number parameter */
    milestoneNumber: number;
    pullNumber: number;
    /** review_id parameter */
    reviewId: number;
    /** asset_id parameter */
    assetId: number;
    /** release_id parameter */
    releaseId: number;
    /** Must be one of: `day`, `week`. */
    per: "day" | "week";
    /** A repository ID. Only return repositories with an ID greater than this ID. */
    sinceRepo: number;
    /** Used for pagination: the index of the first result to return. */
    startIndex: number;
    /** Used for pagination: the number of results to return. */
    count: number;
    /** Identifier generated by the GitHub SCIM endpoint. */
    scimGroupId: string;
    /** scim_user_id parameter */
    scimUserId: string;
    /** Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`. */
    order: "desc" | "asc";
    teamId: number;
    /** gpg_key_id parameter */
    gpgKeyId: number;
  };
  headers: {
    link?: string;
    "content-type"?: string;
    "x-common-marker-version"?: string;
    "x-rate-limit-limit"?: number;
    "x-rate-limit-remaining"?: number;
    "x-rate-limit-reset"?: number;
    location?: string;
  };
}

export interface operations {}
